<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 5 | 己の不学を恥じる</title>
  <meta name="author" content="garasubo">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="己の不学を恥じる">

  
    <meta property="og:image" content="undefined">
  
  <meta property="og:type" content="website">
<meta property="og:title" content="己の不学を恥じる">
<meta property="og:url" content="http://garasubo.github.io/hexo/page/5/index.html">
<meta property="og:site_name" content="己の不学を恥じる">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="己の不学を恥じる">
<meta name="twitter:creator" content="@garasubo">

  <link href="/hexo/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="己の不学を恥じる" type="application/atom+xml">
  <link rel="stylesheet" href="/hexo/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-130790601-1', 'auto');
	ga('send', 'pageview');

</script>


</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/hexo/">己の不学を恥じる</a></h1>
  <h2><a href="/hexo/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/hexo/">Home</a></li>
    
      <li><a href="/hexo/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<a href="https://github.com/garasubo"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-08-12T07:08:15.000Z"><a href="/hexo/2017/08/12/galago.html">2017-08-12</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2017/08/12/galago.html">System76でGalago Proを購入</a></h1>
  

    </header>
    <div class="entry">
      
        <p>使っていたノートパソコンが全く起動しないレベルで壊れたので新しいものを購入することにした。<br>趣味の開発で使うのが主な用途となるのだが、スペックの条件としては</p>
<ul>
<li>メジャーなLinuxディストリビューションが動きそう</li>
<li>ディスク容量500GB以上（256GBだとすぐかつかつになったので）</li>
<li>そこそこ強いCPUとそこそこ大きいメモリ</li>
<li>持ち運びを考えて重量は1.5kg以下</li>
</ul>
<p>はじめはLet’s Noteなども検討したが、20万円を超える額が必至だったので断念。<br>それで友人に勧められたのが<a href="https://system76.com/laptops/galago" target="_blank" rel="noopener">System76のGalago Pro</a></p>
<p>デフォルトOSとしてUbuntuが入っており、ディスク容量やCPUスペックなどもカスタマイズ可能。<br>なんでも10年くらいLinuxの乗るPCを販売している会社らしく、デバイスの不具合もちゃんとパッチを投げて対応しているらしい。<br>値段も海外の会社ゆえ送料が結構かかるのだが、それ込みでも20万円切る価格で買えた。<br>自分が注文した時期が良かったのか、注文から届くまで2週間かからなかった。</p>
<img src="/hexo/images/galago01.jpeg" title="galago pro">


<img src="/hexo/images/galago02.jpeg" title="galago pro">

<p>その他良い点としては</p>
<ul>
<li>Ubuntuのバージョンとして16.04と17.04を選択できた</li>
<li>画面の解像度がデフォルトでは細かすぎて字が小さいのだが、設定でいい感じになおせた</li>
</ul>
<p>注意点・不満点としては</p>
<ul>
<li>ACアダプタがアメリカ仕様のため変換アダプタが必要（変圧は必要なし）</li>
<li>キーボードは英字キーボードのみ（最近、英字キーボードを使う場面が増えていたのでそこまで問題ではなかった）</li>
<li>購入の手続きでクレジットカードの利用明細に記されたコードを送信するのがちょっと面倒<ul>
<li>不正利用防止のためとして、利用明細に記されたコードを送るのだが、購入の情報がウェブの利用明細に反映されるまで3日ほどかかった</li>
</ul>
</li>
<li>バッテリー持ちはそんなによくない。多分4時間位</li>
<li>Xenを入れたら起動しなくなった</li>
</ul>
<p>あとは耐久性が気になる。以前使っていたのが1年位使って一度SSDが死んでメーカー修理に出して、その1年後今度は初期の起動エントリーすら出ないレベルで死ぬということになったので、そういうことにならないといいな。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-23T12:19:59.000Z"><a href="/hexo/2016/05/23/t-visor.html">2016-05-23</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2016/05/23/t-visor.html">ARM向け自作ハイパーバイザーT-Visorを公開しました</a></h1>
  

    </header>
    <div class="entry">
      
        <p>修士の研究としてつくったARM用ハイパーバイザ「T-Visor」を公開しました。<br><a href="https://github.com/garasubo/T-Visor" target="_blank" rel="noopener">https://github.com/garasubo/T-Visor</a></p>
<p>(2016/05/24 ちょっと加筆しました）</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>組み込みの世界でもLinuxのような汎用システム向けOSが使われるようになる一方、<br>リアルタイム性の保障やセキュリティ等の観点からリアルタイムOSの需要も高い。<br>そこで、ハイパーバイザを使って汎用OSとリアルタイムOSを同時に動かす、というような研究や製品が結構あります。<br>具体例を上げれば、ロボットの姿勢制御などをリアルタイムOSできっちりとやる一方、<br>画像処理やネットワーク機能とかを使ってクールな機能だけど最悪バグっても安全には支障がないといったものをLinux側で、といった感じです。<br>実際にARMの一部シリーズではIntel VT-xのような仮想化支援のハードウェア機構が備わっていて、<br>KVMやXenはこれらに対応してARM上でも動くようになっています。</p>
<p>しかし、XenやKVMはLinuxをベースにしていてシステム全体が重い、リアルタイムでないなどの問題点があります。<br>Linuxなどのスケジューラは短い一定周期ごとに確実にこれこれをしなければいけない、といったような要請（ハードリアルタイム）を満たしにくいことが知られています。<br>リアルタイム性や組み込み用途というものを重視しようということで開発したのがT-Visorです。<br>このT-Visorは動作にLinuxやその他標準ライブラリを要さず、Cortex-A7/A15での動作が可能です。<br>方式としてはハードウェア上で直接動くType-1型で、仮想マシン上で動くOSをに対して変更がいらない完全仮想化をおこなっています。</p>
<h2 id="ざっくりとした技術的な説明"><a href="#ざっくりとした技術的な説明" class="headerlink" title="ざっくりとした技術的な説明"></a>ざっくりとした技術的な説明</h2><p>このT-VisorはARMv7-Aの拡張のひとつである<a href="https://www.arm.com/ja/products/processors/technologies/virtualization-extensions.php" target="_blank" rel="noopener">Virtualization Extensions</a>を利用することで、<br>完全仮想化Type-1型のハイパーバイザを実現しています。<br>この拡張でHypモードというプロセッサモードが追加され、プロセッサ全体に影響を与えるような命令に対してトラップをかけてこのHypモードにさせる、ということが可能です。</p>
<p>メモリアクセスですが、通常のMMUに加えてStage-2のMMUというものがあり、これは仮想マシン上での物理アドレスを中間物理アドレスとして受け取り、<br>実物理アドレスに変換させたうえでメモリアクセスをさせると言うものです。<br>これにより、仮想マシンは自由にMMUを使うことができる一方、ハイパーバイザ側でアクセスできるメモリ領域を制限することができます。</p>
<p>仮想デバイスドライバは基本的には実装していません。ARMのIOはすべてMMIOなので、アクセスできるメモリ領域を制限することで、<br>仮想マシンから触れるデバイスは制限されています。<br>また、外部からの割り込みも一度ハイパーバイザにトラップされるので、割り込みについてもどの仮想マシンが受け取るかを制御できます。</p>
<p>割り込みに関してはGICという割り込みコントローラで管理されています。<br>ゲストOSもこのGICを使って割り込みをコントロールするので、競合が起きないよう対応が必要です。<br>このGICはある程度の部分が仮想化対応されているのですが、ある程度の部分に関してはなされていないので、<br>先述のStage-2 MMUを使うことで、アクセスをコントロールすることで仮想割り込みコントローラを実装して対応します。</p>
<p>リアルタイム性を保障するためスケジューリング方式が重要になってきますが、ユーザーが設定しやすいようにということを意識してフレームワークが設計されています。<br>具体的には実装すべき関数をいくつか定め、その中ではあくまでスケジューリングに関することのみを行い、<br>仮想マシン内部などには干渉する必要がないようにされています。<br>サンプルとして固定優先度式とEDF方式のスケジューラが実装されていますが、設定により静的にひとつのスケジューラのみが組み込まれるようになっています。</p>
<p>仮想マシンの数やそのメモリ割当等の設定はコンパイル時に決定されます。<br>現状はソースコードにベタ書きしていく感じになっているので、まともなconfigureについてはfuture workのひとつです。</p>
<p>起動に関してですが、ブートローダはU-Bootを使って動作させていました。<br>ただし、U-Boot固有の機能に何か依存していたわけではなく、メモリ上に外部からハイパーバイザとゲストOSが展開できるようなものならなんでもよいです。</p>
<p>動作確認として無修正のLinuxを動かし、各種ベンチマークの動作を確認しました。<br>また、複数のリアルタイムOSを動かして、OS間通信ができることも確認しています。<br>Xen4.4とも比較実験をおこなっていて、詳細は省きますが、基本的にポジティブな結果が出ました。<br>ただし、Xen4.5で割り込みに関して性能改善がなされたらしく、そちらとはまだ比べられていません。</p>
<h2 id="主要なソースコードの中身"><a href="#主要なソースコードの中身" class="headerlink" title="主要なソースコードの中身"></a>主要なソースコードの中身</h2><p>ソースコード読みたい人向けに簡単に説明しておきます。</p>
<ul>
<li>vcpu.c<ul>
<li>仮想CPUの状態管理を行う</li>
</ul>
</li>
<li>hyp_call.c<ul>
<li>仮想マシンからのhyp例外を管理する</li>
</ul>
</li>
<li>virtual_gic.c<ul>
<li>割り込みコントローラについての仮想化を担っている</li>
</ul>
</li>
<li>schedulers/<ul>
<li>各種スケジューラの実装</li>
</ul>
</li>
<li>users/<ul>
<li>この以下のディレクトリのうちひとつを選択することで、ハイパーバイザ上でどのようなアプリケーションを使うかを決定する</li>
</ul>
</li>
<li>boards/<ul>
<li>ハードウェア依存部分を置くところ。</li>
</ul>
</li>
</ul>
<h2 id="課題と今後やりたいこと"><a href="#課題と今後やりたいこと" class="headerlink" title="課題と今後やりたいこと"></a>課題と今後やりたいこと</h2><p>まず第一に、複数OSは動かせることは確認しているものの、ひとつのVMに対して仮想CPUを複数提供することには失敗しています。<br>また、このハイパーバイザはコアをひとつしか使うことができません。<br>前者に対してはPSCIというコアを管理するためのインターフェースがARM側では定義されているので、<br>それに乗っ取り、仮想CPUを操作するインターフェースを実装済みではあるのですが、いざLinuxを動かしてみると起動途中で止まってしまいます。<br>どうも２つのコアとも処理できるスレッドがなくなってスリープしているようなのですが、はっきりとした原因がわかっていません。<br>原因として考えられるのは</p>
<ul>
<li>割り込みコントローラの仮想化部分がバグっていてハードウェアからの信号待ちのようになってしまって動かなくなっている</li>
<li>コア間の状態保存・復帰がバグっている</li>
<li>キャッシュ・TLBなどが適切にcleanできていない<br>などなのですが、未だにはっきりとつかめていません。</li>
</ul>
<p>また、仮想マシンの管理のconfigがよくない感じなのは前述のとおりなのですが、それ以外にもコードの構造がひどいことは重々承知していて、<br>そこをまず叩き直さなければならないという話もあります。<br>そもそも一人で書いているはずなのに気分でコード規約が変わって名前の付け方が色々おかしいとか、もしかしたらインデントも統一されていない部分もあるかも…<br>あとは今のところ全部C言語とアセンブラで書かれているのですが、C++で書くともっとすっきりするかもしれませんね。</p>
<p>OSや組み込み開発に対してほとんど知識がない状態ではじめたため、かなり拙い部分もありますが、まあなんとか動作することができたのはよかったかなっと</p>
<h2 id="補足"><a href="#補足" class="headerlink" title="補足"></a>補足</h2><p>現在、動作確認は<a href="http://www.zuiki.co.jp/products/cubieboard2/" target="_blank" rel="noopener">Cubieboard 2</a>で行っています。<br>Raspberry Pi2だと割り込みコントローラの関係上、動かすのに大変な労力が必要となります。</p>
<p>あと、課題とかいろいろ書きましたが、現在は基本的に開発止まっています。<br>私の能力では解決が難しいというのがひとつ、つくったとしてもそれを使ったアプリケーションをつくる機会がないといったモチベーションの問題がひとつです。<br>ただ、興味ある人がいれば連絡くれると幸いです。ある程度協力できると思います。</p>
<p>ちなみにこのタイミングで公開したのは、ソースコードを多少はマシにしたかったというのもそうなのですが、<br>これについて書いた論文がリジェクトされたからです。<br>評価が甘かったりアプリケーションが見えにくかったというのが主な原因なのだろうか、アカデミアの道は厳しいですね。<br>この手の分野はクローズドソースなものが多すぎたり、ハードウェア依存な部分が多かったりで、実装までこぎつけても評価が…ってなるのは悲しい</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-12T05:59:08.000Z"><a href="/hexo/2015/12/12/advent.html">2015-12-12</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2015/12/12/advent.html">論文紹介ー&quot;Jitsu: Just-In-Time Summoning of Unikernels&quot;</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="http://www.adventar.org/calendars/828" target="_blank" rel="noopener">システム系論文紹介 Advent Calendar 2015</a>の12日目の記事です。</p>
<h1 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h1><ul>
<li>タイトル： Jitsu: Just-In-Time Summoning of Unikernels</li>
<li>著者：Anil Madhavapeddy, Thomas Leonard, Magnus Skjegstad, Thomas Gazagnaire, and David Sheets</li>
<li>会議：12th USENIX Symposium on Networked Systems Design and Implementation (NSDI 15)</li>
<li>URL：<a href="https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/madhavapeddy" target="_blank" rel="noopener">https://www.usenix.org/conference/nsdi15/technical-sessions/presentation/madhavapeddy</a></li>
</ul>
<p>Jitsuという、Unikernelを使う組込みプロセッサでWebサービスを提供するためのツールをつくりましたというお話。<br>著者は<a href="https://mirage.io/" target="_blank" rel="noopener">MirageOS</a>を開発でお馴染みの方々が並んでいますね。<br>会議は今年のNSDIで、USENIX系の会議なので論文も著者のスライドも無料で手に入るので、<br>こんなブログを読まずともそちらを読んでしまえば全て完了するのではという気がしますが…</p>
<h2 id="予備知識"><a href="#予備知識" class="headerlink" title="予備知識"></a>予備知識</h2><p>最近ちょくちょく話題になりこの論文のキーともなるUnikernelについて簡単に説明しておこうと思います。</p>
<p>Unikernelとは、動かすプロセスを1つに限定することで様々なOSの抽象化を簡略化してライブラリのようにすることで、<br>アプリケーション単体でプロセッサで動くイメージとしたもの、といったとこでしょうか。<br>代表的なのは<a href="https://mirage.io/" target="_blank" rel="noopener">MirageOS</a>とか<a href="http://osv.io/" target="_blank" rel="noopener">OSv</a>とかですね。<br>Unikernelの詳しい説明については、<br><a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf" target="_blank" rel="noopener">Unikernels: Library Operating Systems for the Cloud</a><br>がよいでしょう。<br>英語版Wikipediaにも記事があります。<br><a href="https://en.wikipedia.org/wiki/Unikernel" target="_blank" rel="noopener">Unikernel - Wikipedia, the free encyclopedia</a><br>もう少し体系的でざっくりとした話だと、このスライドとかわかりやすいかもしれません。<br><a href="https://speakerdeck.com/ntddk/an-introduction-to-drawbridge-ja" target="_blank" rel="noopener">An Introduction to Drawbridge(ja) // Speaker Deck</a></p>
<p>今回使うUnikernelはMirageOSなのですが、これはOCamlで書かれており、<br>OCamlにはARM用のコンパイラがあること、MirageOSが動作する環境であるXenがARM向けに対応していることなどが幸いしてか、<br>一部のARMボード上（CubieBoard2など）で動作するようです。<br>私も試してみようとCubieBoard2を購入したのですが、コンパイルでこけてしまいましたが。</p>
<h1 id="論文の中身"><a href="#論文の中身" class="headerlink" title="論文の中身"></a>論文の中身</h1><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>クラウド環境からサービスを提供することが流行っているが、クラウド環境への通信のオーバーヘッドが厄介。<br>また、IoTのデバイスはセキュリティの脆弱性が問題になる。<br>そこで、組込みハードウェア上でXenなどのハイパーバイザを動かしサービスを提供できれば、<br>ユーザーに近い位置でのサービス提供が可能となるため通信のレイテンシが緩和される。<br>また、ハイパーバイザを使うことで各サービスを独立で動かせる。</p>
<h2 id="実現したこと"><a href="#実現したこと" class="headerlink" title="実現したこと"></a>実現したこと</h2><p>組込みデバイスで動くネットワークアプリケーションをセキュアに管理するためのツールを、Xenのツールスタックとして実装した。<br>VMとしてUnikernelを使うことでより低いlatencyでネットワークリクエストに応答する。</p>
<h2 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h2><p>XenのツールスタックをXenStoreを拡張し実装。<br>目標としては、サービスがネットワークに対してきちんと応答するようにするが、必要のないときはリソースがもったいないのでサービスを停止させましょうというもの。<br>そのために</p>
<ul>
<li>Unikernelのブート時間の最適化</li>
<li>VM間コミュニケーションプロトコル”Conduits”の実装</li>
<li>外部クライアントからのアクセスに対して、起動時間のレイテンシを隠蔽するためのディレクトリサービス”Synjitsu”の実装<br>を行っている。<br>Xen上でVMの設定値を管理・保存するためのツールスタック<br>XenStoreを拡張することによって行なわれる。</li>
</ul>
<h3 id="ブート時間最適化"><a href="#ブート時間最適化" class="headerlink" title="ブート時間最適化"></a>ブート時間最適化</h3><p>起動時の仮想デバイスの割りあてを並列処理したことと、<br>OCamlによるXenStoreトランザクションを利用することで高速化。<br>また、Unikernelを用いるたので、そもそものバイナリサイズが小さいためそれも高速化に寄与している。</p>
<h3 id="Conduits"><a href="#Conduits" class="headerlink" title="Conduits"></a>Conduits</h3><p>vchanという共有メモリを用いたデータパスを利用し、OCamlでvchanのプロトコルを実装。<br>ランデブーのためのインターフェースがvchanにはないので、XenStoreの名前空間を拡張してランデブーインターフェースを提供。</p>
<h3 id="Directory-Service"><a href="#Directory-Service" class="headerlink" title="Directory Service"></a>Directory Service</h3><p>DNSのリクエストをどのUnikernelに割り当てるかをマップしているもの。<br>DNSのリクエストによりUnikernelが起動し、その後外部クライアントからTCPのリクエストが送られてくるのだが、<br>起動が完了していないとリクエストに応答できない。<br>そこで、起動前の場合、ひとまずリクエストをXenStoreに保存しておき、Unikernelとの間に割り込んでいるSynJitsuがTCPのACKを返しておく。<br>その後、Unikernelが起動すると溜まったリクエストへの応答を開始し、Synjitsuを介さずにクライアントとUnikernelが直接やり取りを開始する。<br>このようなことをしないと起動前のTCPパケットがタイムアウトして再送までの時間がかかってしまうため、<br>サービスのレスポンスが下がってしまう。<br>わかりやすい図が論文にあるので、そちらを参照されたい。</p>
<h2 id="評価"><a href="#評価" class="headerlink" title="評価"></a>評価</h2><p>いろいろなパフォーマンスを計測するための実験を行っているが、<br>そもそもARMボード上でこのようなことをやるというのがなく、<br>比較ができていないといった印象を受けた。<br>セキュリティに関しては、CVEのリストにある脆弱性のうち、どれがJitsuでは影響があるか調べている。<br>Unikernelを用いているため、<br>基本的にはLinuxのデバイスドライバ部分やカーネルそのものバグとXenに関するものしか受けず、<br>SSH overflowのようなアプリケーションよりのものは影響を受けない。</p>
<h2 id="関連研究・議論"><a href="#関連研究・議論" class="headerlink" title="関連研究・議論"></a>関連研究・議論</h2><p>コンテナ型仮想化であるDockerやDrawbridgeなどが紹介されている。<br>UnikernelがよりOSの各種抽象化を省略しアプリケーション特化の構成になっている。</p>
<p>この研究はXenのABIを変えたりなどはしていないため、他のツールと併用することも可能。<br>ConduitsもMirageOSに特化したものではないため、プロトコルを実装すれば他のunikernelでも利用可能。</p>
<h2 id="まとめ・私見・愚痴"><a href="#まとめ・私見・愚痴" class="headerlink" title="まとめ・私見・愚痴"></a>まとめ・私見・愚痴</h2><p>Unikernelを使うことでARMボード上でWebサービスを素早く提供できるJitsuというXenのツールスタックを実装した、というものでした。<br>全体的に雑な説明になってしまいましたが、まあ、細かい話は論文を直接読んだほうがいろいろ手っ取り早くわかるでしょう。</p>
<p>最近ではDockerでUnikernelを動かすとかよくわからない話も上がってきたりして、<br>段々と注目度が上がっているようなので、このようなUnikernelを活用したシステムがこれからもいろいろと出てくるのでしょうか。</p>
<p>12日目といってもまだ2人目ですね。<br>システム系やっている人ってやっぱり少ないなあと思うし、<br>成果を出すのに時間がかかることが多かったりするせいか評価されることも少ないし、<br>いろいろとつらいなあと思う今日このごろ。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-26T12:39:38.000Z"><a href="/hexo/2015/02/26/arch.html">2015-02-26</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2015/02/26/arch.html">LaVie Z750にWindows 8.1+Arch Linuxのデュアルブート環境構築</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今使っているLet’s noteがパーティション分けミスってLinuxの容量がかつかつになってしまったっていのと、ハードウェア的にポツポツと不具合が出てきていたので、新しいパソコンを買った。<br>LaVie Z750を選んだのは軽いのと、SSD 256GBにOffice付きのわりに安かったから。</p>
<p>今までUbuntuに甘えてきたが、思い切ってArch Linuxにすることにした。<br>Gentooも考えたが以前挫折したこと、資料がArchのほうが充実している感じだったことを考慮してArchを選んだ。<br>Archのバージョンは2015.01.01のを使った（以前ダウンロードしていたので）。</p>
<p>基本的には公式wikiのBeginner’s guideに従うだけ。<br>英語と日本語があるが、英語のほうがinstallまでの説明が詳しい一方、日本語はinstall後の作業の説明がついている。<br><a href="https://wiki.archlinux.org/index.php/Beginners%27_guide" target="_blank" rel="noopener">Beginners’ guide - ArchWiki.html</a><br><a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide_%28%E6%97%A5%E6%9C%AC%E8%AA%9E%29" target="_blank" rel="noopener">Beginners’ Guide (日本語) - ArchWiki</a> </p>
<p>躓いたのはまずパーティション分け。<br>今回取った方法は</p>
<ol>
<li>Windowsのコントロールパネルから「管理ツール」→「ハードディスク パーティションの作成とフォーマット」でWindowsパーティションを縮小</li>
<li>Archのブートメディアから<code>gdisk</code>で空領域にパーティションを作って、<code>mkfs.ext4</code>で初期化<br>というもの。</li>
</ol>
<p>あとはインストール中の<code>/boot</code>にどこをマウントするか。<br>/dev/sda2をマウントすればいいのだが、はじめはこれをスキップしてしまい、後々面倒なことになった。</p>
<p>日本語環境化はここが参考になった。<br><a href="http://note.kurodigi.com/post-0-19/" target="_blank" rel="noopener">Arch Linuxに日本語環境を構築する</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-25T05:09:10.000Z"><a href="/hexo/2015/02/25/virt.html">2015-02-25</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2015/02/25/virt.html">Xenで使っているディスクイメージの容量拡張</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Ubuntu 14.04にXenを入れてその上でArch Linux(2015-01版）を動かしている。<br>ディスク容量が足りなくなったので増やそうと思ったのだが、virt-managerあたりからはいけそうな雰囲気がなかったので、<br>適当に調べた方法を試したら上手くいった。</p>
<p>念の為、ディスクイメージのバックアップをとっておくことを推薦</p>
<ol>
<li><p>Ubuntu上でディスクイメージの後ろにほしい長さ分だけ追加<br> ディスクイメージは<code>/var/lib/libvirt/images</code>の中とかにある。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/zero <span class="attribute">bs</span>=512M <span class="attribute">count</span>=20 &gt;&gt; arch.img</span><br></pre></td></tr></table></figure>
</li>
<li><p>ゲストOS上でパーティションを再構築<code>fdisk</code>とかで一番後ろのパーティションを一度<code>d</code>で破壊して、<code>n</code>でもう1回つくるとき後ろまで最大限まで伸ばす。<br> その後<code>w</code>で保存。自分の場合、マウントされているパーティションを伸ばしているので、認識させるには一度再起動する必要がある。</p>
</li>
<li><p>再起動後、<code>resize2fs</code>でパーティションを拡張、<code>df -h</code>でパーティションが拡張されていることを確認。</p>
</li>
</ol>
<p>参考：<a href="https://mistymagich.wordpress.com/2014/08/16/xen%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%82%92%E6%8B%A1%E5%BC%B5%E3%81%99%E3%82%8B/" target="_blank" rel="noopener">Xenで使用しているディスクイメージを拡張する | misty-magic.h</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-24T13:44:26.000Z"><a href="/hexo/2014/12/24/hexo.html">2014-12-24</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2014/12/24/hexo.html">あなたとHexo</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Octopressの動作が最近よくわからないけど不安定なのと、<br>どこかでHexoいいよという話を聞いたので、このブログのHexo移転を考えている。</p>
<p><a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a></p>
<p><a href="http://liginc.co.jp/web/programming/server/104594" target="_blank" rel="noopener">所要時間3分!? Github PagesとHEXOで爆速ブログ構築してみよう！ | 株式会社LIG</a></p>
<p><a href="http://www.techelex.org/octopress-vs-hexo/" target="_blank" rel="noopener">Octopress vs Hexo</a></p>
<p>Octopressからの移行は楽で、記事のmarkdownファイルを移動してきて、configをいじってあげればよい。</p>
<p><a href="http://hexo.io/docs/migration.html" target="_blank" rel="noopener">Migration | Hexo</a></p>
<p>それで新しくつくったブログがこちら。<br>もうちょっとしたらこちらに移す。</p>
<p><a href="http://garasubo.github.com/hexo" target="_blank" rel="noopener">新しいブログ</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-07T12:38:00.000Z"><a href="/hexo/2014/12/07/advent.html">2014-12-07</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2014/12/07/advent.html">論文紹介ー&quot;User-guided device driver synthesis&quot;</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="http://www.adventar.org/calendars/440" target="_blank" rel="noopener">システム系論文紹介 Advent Calendar 2014</a>の7日目の記事です。</p>
<h2 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h2><ul>
<li>タイトル： User-guided device driver synthesis</li>
<li>著者：Leonid Ryzhyk, Adam Walker, John Keys, Alexander Legg, Arun Raghunath, Michael Stumm, Mona Vij</li>
<li>会議：11th USENIX Symposium on Operating Systems Design and Implementation</li>
<li>URL： <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-ryzhyk.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-ryzhyk.pdf</a></li>
</ul>
<p>デバイスドライバをユーザーが指示を出しつつ半自動でデバイスドライバを合成するツールTermiteというものを提案しています。<br>この著者はこのTermiteというツールを<a href="http://doi.acm.org/10.1145/1629575.1629583" target="_blank" rel="noopener">Automatic Device Driver Synthesis with Termite</a>という論文で<br>その2つのやり取りをオートマトンとしてみて、その上で行なわれるゲームの必勝法としてデバイスドライバの合成をしてやろうというものです。</p>
<p>当初は完全自動だったのですが、現代の科学では完全自動だと厳しいものがあると悟った著者らがユーザーの入力補助をうまく取り入れるという<br>方針に変えてこのような形になったようです。<br>この論文は今までやってきたことのまとめ、という形になっているようです。</p>
<h2 id="Specificationの書き方"><a href="#Specificationの書き方" class="headerlink" title="Specificationの書き方"></a>Specificationの書き方</h2><p>このTermiteへの入力として必要なのはdriver, device, OSそれぞれのmodelのspecificationです。<br>これはTermite Specification Language（TSL）によって与えられます。</p>
<p>TSLの具体例は論文にあります。</p>
<h3 id="Device-model"><a href="#Device-model" class="headerlink" title="Device model"></a>Device model</h3><p>デバイスの動作についてのモデルです。<br>デバイスがどのように動くかは<br>デバイスのデザイナーが持っているはずのtransaction-level models（TLM）から簡単にわかります。<br>ただし、ベンダーが非公開にしている場合も多く、TLM to TSLのコンパイラも開発中とのこと。</p>
<p>デバイスモデルを仕様書から書き起こす方法についてはSOSPの論文の方に詳しく議論されていましたが、この論文ではされていませんでした。</p>
<h3 id="OS-model"><a href="#OS-model" class="headerlink" title="OS model"></a>OS model</h3><p>OSがドライバに向けて発行するAPIを構築するためのモデルです。<br>イーサーネットならパケットを送るとか受け取るとかそんな感じです。</p>
<h3 id="DeviceとOSモデルをつなげる"><a href="#DeviceとOSモデルをつなげる" class="headerlink" title="DeviceとOSモデルをつなげる"></a>DeviceとOSモデルをつなげる</h3><p>このデバイスとOSの定義の関係する状態を結びつける必要があるのですが、<br>この2つの定義をできるだけ独立に保ちたいという要請もあります。</p>
<p>そこで、virtual interfaceというものを導入しています。<br>これはデバイスモデルの重要なイベントをOSに通知するコールバックみたいなものです。<br>これは実際に合成されるデバイスドライバの動作というわけではなく、<br>これで定義を与えてやろうというものです。</p>
<p>また、ドライバの動きを制限するassertや、ドライバがどこに向かっていくのかを定義するgoalというものも定めることができます。</p>
<h3 id="ドライバテンプレート"><a href="#ドライバテンプレート" class="headerlink" title="ドライバテンプレート"></a>ドライバテンプレート</h3><p>OSが実際に呼び出す関数を定めるテンプレートです。</p>
<h2 id="User-guided-code-generation"><a href="#User-guided-code-generation" class="headerlink" title="User-guided code generation"></a>User-guided code generation</h2><p>コードの合成はIDEで編集するという感じでおこなわれます。<br>このIDEの機能としてgeneratorとverifierがあります。<br>generatorが自動補完のように現在の入力位置にモデルから合成したコードを埋め込むことができます。<br>もちろん、合成したコードに対しての変更も可能です。<br>verifierが書かれたコードが定義に合っているかどうかをチェックします。</p>
<h2 id="Synthesis"><a href="#Synthesis" class="headerlink" title="Synthesis"></a>Synthesis</h2><p>モデル間の合成なのですが、これはデバイス・OSとドライバ間でおこなわれるゲームと見立てることでおこなわれます。<br>ゲームの状態を有限オートマトンとして、状態遷移はコントロール可能なものとドライバやOSが勝手に行うコントロール不可能なものの2つです。<br>このゲームに勝つ戦略、すなわちなってはならない状態に陥らないように行動するのがドライバで、これを合成するというわけです。<br>このゲームに勝つ戦略がそもそも存在しない場合、合成は失敗となります。</p>
<p>この合成は下手に行うと状態数爆発を起こしたりと厄介なのですが、<br>それを起こさないため、筆者は様々な工夫をしています。</p>
<p>詳しいことを書いているとキリが無いので、ここでは省略します。<br>また、この論文より他の関連する論文のほうが詳しく書かれているようです。<br>（私は読んでいません）</p>
<h2 id="Debugging-with-counterexamples"><a href="#Debugging-with-counterexamples" class="headerlink" title="Debugging with counterexamples"></a>Debugging with counterexamples</h2><p>このゲームベースの合成に失敗した時のデバッグ支援方法もTermiteは備えています。<br>ゲームに勝つ戦略を妨げている環境の振る舞い、counterexample strategiesを探します。<br>これはこのゲームの双対ゲームを解くことで得られます。<br>このcounterexample strategyをステップ実行することで、デバッグを支援します。</p>
<h2 id="Limitations-of-Termite"><a href="#Limitations-of-Termite" class="headerlink" title="Limitations of Termite"></a>Limitations of Termite</h2><ul>
<li>DMAを扱えない<ul>
<li>状態数が爆発する</li>
</ul>
</li>
<li>デバイスコントロールとは本質的に関係ないところは他の手法を使うことで簡単に合成できるが、現在のところでは手動で埋め込むしかない</li>
<li>並列処理への対応ができない</li>
<li>リアルタイム性の保障はできないので、ハードリアルタイムなドライバはつくれない</li>
</ul>
<h2 id="Implementation-and-evaluation"><a href="#Implementation-and-evaluation" class="headerlink" title="Implementation and evaluation"></a>Implementation and evaluation</h2><p>このTermite、Haskellのコードおよそ3万行で10人年かかっているとのこと。<br>USBのwebカメラ、UARTのシリアルコントローラなどを実際に実装して評価しています。<br>各デバイスドライバに実装するのに1週間ほど（ドキュメントを読んでデバイスの仕様を調べる時間も含まれている）とのこと。</p>
<p>合成アルゴリズムも、提案している手法と従来手法を比べ、従来手法だと2時間以内に終わらなかったものが、1分〜10分ほどで終わっていることが示されています。<br>verificationはまだ最適化されていないため、合成より時間はかかっていますが、それでも最大でも13分ほどしかかかっていません。</p>
<p>実際に出来上がるドライバはどうしても手動での最適化や変更が必要なのですが、60%〜90%は自動で合成できたようです。</p>
<p>また、できあがったコードサイズなのですが、これも全体的に小さくなっています。<br>これは、このドライバがデバイス動かすロジックに集中していること、<br>普通のデバイスドライバはコードの再利用などを考えて冗長になっていることなどが挙げられるようです。</p>
<p>この方法では定義の再利用が可能というのが1つの売りなのですが、これについてもOSを変えたることで試しています。<br>これも定義をほとんど変えることなく再利用できたとしています。</p>
<p>パフォーマンスもほぼ同等とのことです。</p>
<h2 id="まとめと私見"><a href="#まとめと私見" class="headerlink" title="まとめと私見"></a>まとめと私見</h2><p>Termiteというデバイスドライバ合成ツールについての論文でした。<br>形式的手法を用いて定義からドライバを合成し、さらにそのデバッグについても形式的手法を用いて支援しているというのはおもしろいと思い、今回この論文を紹介しました。<br>私自身、デバイスドライバを書いたことは一切なく、専門分野でもなく少々準備が甘くなりつたない文章となってしまいましたが、<br>ご指摘・マサカリ等ありましたら、コメントお願いします。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-07T01:28:00.000Z"><a href="/hexo/2014/10/07/vmware.html">2014-10-07</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2014/10/07/vmware.html">UbuntuにインストールされたVMware Playerをアンインストール</a></h1>
  

    </header>
    <div class="entry">
      
        <p>タイトルの通り。aptで入れたわけでないのでどうするのかなあと思ったら、<br><code>vmware-uninstall</code>ってコマンドあったから打ってみたところ、</p>
<pre><code>The vmware-uninstall* scripts have been deprecated.  Instead, please use
the vmware-installer.

Long form:
  vmware-installer --uninstall-product PRODUCT
Short form:
  vmware-installer -u PRODUCT</code></pre><p>とのこと。</p>
<p>なのでおとなしく、<code>vmware-installer --uninstall-product vmware-player</code>と入れたら消えたみたい。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-09-27T01:52:32.000Z"><a href="/hexo/2014/09/27/android.html">2014-09-27</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2014/09/27/android.html">Android開発あれこれ</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Android開発したときのあれこれをまとめ</p>
<h1 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h1><p><a href="https://developer.android.com/sdk/installing/studio.html" target="_blank" rel="noopener">Android Studio | Android Developers</a></p>
<p>公式のSDK。IntelliJベースで、補完とかがとても優秀。<br>Viプラグインも結構気に入っている。<br>gitignoreとかもデフォルトでちゃんとしていたりと。<br>ビルドツールもなかなかよい。<br>ただし、gitプラグインの使い勝手はイマイチ。<br>まあ、それは別の方法で叩けばいいだけの話であって、<br>これなしでのAndroid開発は考えられない。</p>
<h1 id="シミュレータ"><a href="#シミュレータ" class="headerlink" title="シミュレータ"></a>シミュレータ</h1><p>実機で走らせるとデバッグ実行できなかったりと色々と不都合なので、<br>シミュレータを使うことになる。<br>しかし、とっても遅くて使い物にならないとまでは言わないが、ストレスがたまる。<br>WindowsとMac用にはIntell製のシミュレータが用意されていてSDKマネージャーからインストールでき、それを使えばそこそこ速いらしい。<br>しかし、自分はUbuntu使っているので、この方法は使えなかった。</p>
<p>他の方法ではGenymotionというシミュレータがあり、こちらのほうが高速との評価をちらちら見る。</p>
<p><a href="http://www.genymotion.com/" target="_blank" rel="noopener">Genymotion</a></p>
<p>こちらは、Virtualbox上で動作する仮想化環境。こちらはUbuntuにも対応しているが、まだ試したことはない。<br>Macbookでは試したが、確かに高速。<br>ダウンロードに個人情報要求されたりするのが癪ではある。<br>トラップとして謎のバグが存在しており、何回かデバッグ実行するとエラーを吐いてアプリが突然死するというものがある。<br>そうなった場合は再起動しなければならない。</p>
<h1 id="ユニットテスト"><a href="#ユニットテスト" class="headerlink" title="ユニットテスト"></a>ユニットテスト</h1><p>Robolectricというのを使った。</p>
<p><a href="http://blog.yohei.org/android-studio-gradle-robolectric1/" target="_blank" rel="noopener">【Android】Android Studio + Gradle + Robolectric！でテストをしよう | Yohei Blog</a></p>
<p><a href="https://github.com/robolectric/deckard-gradle/" target="_blank" rel="noopener">robolectric_deckard-gradle · GitHub</a></p>
<p>ここらへんを見ながらなんとか導入。<br>罠なのが、Android Studioが勝手にパッケージ宣言を補完してくるところで、これがあるとテストが動かない。<br><code>gradle check</code>コマンドで簡単にテストできる。ターミナルで実行するよりSDKから叩いたほうが高速（理由はよく知らないけど中間ファイルか何かを再利用していたりするのか）。<br>画面遷移等もチェックできるらしのだが、そこまではよく分からなかった。<br>しかし、Shared PreferenceとかAndroid固有の機能が絡んでくる動作もちゃんとテスト出来るのはうれしい。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-07-12T10:16:00.000Z"><a href="/hexo/2014/07/12/icpc.html">2014-07-12</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2014/07/12/icpc.html">ICPC2014参戦記</a></h1>
  

    </header>
    <div class="entry">
      
        <p>ICPC2014国内予選参加しました。<br>結果は5完の24位でアジア地区予選には自明に進めないのでここでおしまい。</p>
<h1 id="解いた問題と方針"><a href="#解いた問題と方針" class="headerlink" title="解いた問題と方針"></a>解いた問題と方針</h1><p>相方にAを任している間に、C,Eの実装を考えて、<br>Aが終わった後、Cを通す。<br>疲れたので相方にBを任せている間に、Dの方針を聞いたり他の問題考えていた。<br>Bが終わった後、DとEを連続して実装して通す。<br>F、Gは歯がたちませんでした。</p>
<h2 id="C問題"><a href="#C問題" class="headerlink" title="C問題"></a>C問題</h2><p>はじめは二部探索かな、と思ったが、判定関数考えているうちに直接求まることに気がつく。</p>
<p>まず、各々のx軸上の区間のビルの高さの最大値を求める。ビルが存在しなければ0とする。<br>i&lt;=0となるような[i-1,i]区間ではx=iの地点がより太陽が先に見えてしまう。<br>i&gt;0となるような[i-1,i]区間ではx=i-1の地点がより太陽が先に見える。<br>よってそれぞれの区間について、太陽が先に見えるx座標とそこの高さに円が到達する時間を求める。<br>そのうち最小のものが答えとわかる。</p>
<p>r&lt;=20という制限により、区間中に存在するビルの高さの最大値は愚直に求まり、<br>到達する時間については2次方程式をさくっと解くだけ。</p>
<h2 id="D問題"><a href="#D問題" class="headerlink" title="D問題"></a>D問題</h2><p>相方から聞いた方針を具体化しただけ。</p>
<p>文字数がたかだか20なので、各文字について変換されたorされないと仮定して復号化、それを暗号化してちゃんと元に戻るかを計算すれば大丈夫、<br>というもので実装した。<br>各文字について変換したかどうかをビットマスクで表現して、’z’を復号化するときだけは例外処理。<br>ちゃんと元に戻った文字列は記録し、最後にソートして出力。</p>
<p>ただ、この方針、すぐには実装できるのだが、最大で2^20*20*25の計算となり、500000000くらいとなり、普通のプロコンだと通用しない計算量となってしまった。<br>（暗号化するかしないかのパターンで2^20通り、暗号化で20*25の処理が入る）<br>ただ、ICPCは制限時間が無く、手元で実行し出力ファイルを提出すればいいだけなので、<br>出力を待っている間、他の問題を実装していれば問題なく正解をもらえた。</p>
<p>もうちょい何とかするとすると、暗号化するところの処理を文字の出現位置とかをメモすることで高速化するか、<br>DFSとかで暗号化できないような文字列は探索しないようにすることでそもそも判定の手間を減らすとかか。<br>あと、ビットマスクの探索順を工夫すれば最後のソートはいらない。<br>まあ、いずれも実装が複雑化しそうなので、これはこれでよかったのかなあ。</p>
<h2 id="E問題"><a href="#E問題" class="headerlink" title="E問題"></a>E問題</h2><p>自明に木構造をしているので、木DP的な何かかなと当たりをつける。<br>ノード数が300と少ないので、全ての点について根であると仮定した場合で回しても十分間に合いそう。<br>終点についてもそれぞれについて終点としてみて試せば300*300*300で間に合うんじゃないか、となったが、<br>擬似コード書き始める時点で、終点を固定して探索するの厄介だなあと考え、もうちょっと考えなおしてみる。</p>
<p>そこで、始点と終点が同じであるパターンからまず考える。<br>始点をAとしておく。<br>葉、つまりこの先に何もない島につながっている橋はわざわざ渡る必要もなく、即座に撤去すれば良い。<br>そうではない島(Bとおく)につながっている橋は、まず、Bより先にある橋を撤去する必要があるので、一度その橋をわたらなければならない。<br>Bについても、Aに戻るためには同じ橋を渡らなければならないので即座には撤去できず、Bよりも先にある橋を全て撤去してBに戻り、<br>Aに戻り、やっとA-B間の橋を撤去出来る。<br>つまり、ある島を始点とした場合、それを根にした木と考えた時、葉をつなぐ橋は即座に撤去し、そうでない橋は2回渡った後撤去することで、<br>全ての橋を撤去できる。始点と終点が同じならこれが最小コストのはずだ。</p>
<p>始点と終点が異なる場合、最後に終点まで行くとき、そのパス上にある橋を渡ることになるが、この時、戻る必要性がないので、渡った時点で即撤去できる。<br>つまり、始点と終点が異なる場合、始点から終点までのパス長ぶん戻るコストを節約できるという訳である。<br>よって、始点と終点が異なる場合の最終コストは始点を固定した場合、その始点から最も長い長さの葉ではない島を終点とした時である。</p>
<p>コードとしては、DFSで始点と終点が同じと仮定した場合のコストを計算しつつ、始点からその島までのコストを持つことで最も遠い島を探すようなコードになった。<br>最も遠い島に関してと始点と終点が同じ時のコストを計算するDFSを分けてもDFS1回の計算量が高々ノード数程度なので、十分に間に合う。</p>
<p>#感想・反省<br>3度目の参戦となり、今までの反省を活かせたんじゃないかなと思っている。<br>1度目は個人としての能力があまりにも低すぎた＆相方がガチ勢だったので、足を引っ張るだけのゴミだったのだが、<br>2度目は自分の能力もそれなりについて、相方もほぼ同レベルだったが、結構足を引っ張ってしまったと反省していた。<br>原因はちゃんと実装を細かいレベルで考えていなかったことで、<br>方針は立っても細かいところでつまり1台しか使えないパソコンをかなり占有してしまった。</p>
<p>今回は相方が実装している間に、実装の細かいところをじっくりと考えたので、実装はかなり早く終わったのではないかな、と思っている。<br>前回の僕であれば、Eで始点・終点それぞれ固定して探索しようで行けると思い込んで実装に詰まっているところだった。<br>あと、チーム全体和やかな雰囲気だったので、練習量も個人の能力もそこそこだった割にはいい成績を残せたのかなと。</p>
<p>ただ、今回も反省はあって、入出力パターンの確認はしっかりやるべきだった。<br>これで1回躓いてしまった。ロスは小さかったかもしれないが、やはり、事前に意識すべき範囲であった。</p>
<p>#まとめ<br>ICPCにおいて最も重要なこと、それはパーフェクト・ハーモニー、完全調和だ！</p>
<p>（強い人に怒られそう）</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/hexo/page/4/" class="alignleft prev">前の投稿</a>
  
  
    <a href="/hexo/page/6/" class="alignright next">次の投稿</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="検索">
    <input type="hidden" name="q" value="site:garasubo.github.io/hexo">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最近の投稿</h3>
  <ul class="entry">
    
      <li>
        <a href="/hexo/2021/12/31/nenmatsu-poem.html">2021年の振り返り</a>
      </li>
    
      <li>
        <a href="/hexo/2021/11/07/rust-memory.html">Rustのメモリ管理機能とその特徴</a>
      </li>
    
      <li>
        <a href="/hexo/2021/08/26/isucon11.html">ISUCON11予選参加記（予選敗退）</a>
      </li>
    
      <li>
        <a href="/hexo/2021/04/04/theseus.html">論文紹介： Theseus: an Experiment in Operating System Structure and State Management</a>
      </li>
    
      <li>
        <a href="/hexo/2021/01/17/eth-tx.html">RustのSTM32向けイーサネットドライバを解説する（送信編）</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
<a class="twitter-timeline" data-height="600" href="https://twitter.com/garasubo">Tweets by garasubo</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>



  

  
<div class="widget tag">
  <h3 class="title">タグ</h3>
  <ul class="entry">
  
    <li><a href="/hexo/tags/Arm/">Arm</a><small>2</small></li>
  
    <li><a href="/hexo/tags/CLI/">CLI</a><small>1</small></li>
  
    <li><a href="/hexo/tags/Cortex-M/">Cortex-M</a><small>2</small></li>
  
    <li><a href="/hexo/tags/Kernel-VM/">Kernel/VM</a><small>2</small></li>
  
    <li><a href="/hexo/tags/Rust/">Rust</a><small>16</small></li>
  
    <li><a href="/hexo/tags/embedded/">embedded</a><small>1</small></li>
  
    <li><a href="/hexo/tags/isucon/">isucon</a><small>5</small></li>
  
    <li><a href="/hexo/tags/osdev/">osdev</a><small>6</small></li>
  
    <li><a href="/hexo/tags/paper/">paper</a><small>10</small></li>
  
    <li><a href="/hexo/tags/procon/">procon</a><small>2</small></li>
  
    <li><a href="/hexo/tags/unikernel/">unikernel</a><small>3</small></li>
  
    <li><a href="/hexo/tags/x11/">x11</a><small>1</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 garasubo
  
</div>
<div class="clearfix"></div>
<div><a href="https://policies.google.com/terms?hl=ja&gl=jp">Google Analyticsを利用しています</a></div>

</footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/hexo/js/jquery.imagesloaded.min.js"></script>
<script src="/hexo/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'garasubo';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/hexo/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/hexo/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
