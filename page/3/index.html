<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 3 | 己の不学を恥じる</title>
  <meta name="author" content="garasubo">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="己の不学を恥じる">

  
    <meta property="og:image" content="undefined">
  
  <meta property="og:type" content="website">
<meta property="og:title" content="己の不学を恥じる">
<meta property="og:url" content="http://garasubo.github.io/hexo/page/3/index.html">
<meta property="og:site_name" content="己の不学を恥じる">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="己の不学を恥じる">
<meta name="twitter:creator" content="@garasubo">

  <link href="/hexo/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="己の不学を恥じる" type="application/atom+xml">
  <link rel="stylesheet" href="/hexo/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/hexo/">己の不学を恥じる</a></h1>
  <h2><a href="/hexo/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/hexo/">Home</a></li>
    
      <li><a href="/hexo/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-07-20T15:00:00.000Z"><a href="/hexo/2019/07/21/unikernel.html">2019-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/07/21/unikernel.html">論文紹介：A Binary-Compatible Unikernel ー Unikernelの解説も添えて</a></h1>
  

    </header>
    <div class="entry">
      
        <p>元論文：<a href="https://dl.acm.org/citation.cfm?id=3313817" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=3313817</a></p>
<p>Linuxアプリケーションをそのまま動かせるバイナリコンパチブルなUnikernelを構築しました、という話です。<br><a href="/hexo/2019/06/30/lightvm.html">前回の記事</a>に引き続きUnikernel関連な話題ですが、意外と自分のブログではUnikernelについての話題を触れていなかったので関連論文も合わせて紹介したいと思います。</p>
<h2 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h2><ul>
<li>タイトル：A binary-compatible unikernel</li>
<li>著者：Pierre Olivier, Pierre Olivier, Pierre Olivier et. al.</li>
<li>会議：Proceedings of the 15th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments (VEE 2019)</li>
</ul>
<p>仮想環境関連のトップカンファレンスであるVEEでの論文です。</p>
<h2 id="Unikernelについて"><a href="#Unikernelについて" class="headerlink" title="Unikernelについて"></a>Unikernelについて</h2><p>Unikernelという概念が初めてでてきたのはASPLOS 2013でのMirageOSの論文です。<br><a href="https://dl.acm.org/citation.cfm?id=2451167" target="_blank" rel="noopener">Unikernels: library operating systems for the cloud</a><br>仮想環境上でアプリケーションを走らせるために、アプリケーションごとに独立した仮想Linuxマシンを立ち上げるのは、どうしてもたくさんの計算資源を消費してしまいます。<br>しかし、Dockerなどのコンテナ仮想化では、特にマルチテナントな仮想環境ではセキュリティの懸念が残ります。<br>そこで彼らのMirageOS、アプリケーションを走らせるためのOSをライブラリとして直接リンクさせるライブラリOS形式を用います。<br>通常、OSは複数のアプリケーションを動かすために計算資源の仮想化を行うわけですが、シングルアプリケーションのためならそのような抽象化レイヤーはいらないという考えです。<br>ライブラリOSの概念自体は古くからあり、SOSP ‘95で発表された<a href="https://dl.acm.org/citation.cfm?id=224076" target="_blank" rel="noopener">Exokernel</a>でも用いられている概念です。<br>ただし、当時はあまりにも極端すぎるアプローチで、特にそのライブラリOS用のデバイスドライバは個別で開発する必要がありました。<br>しかし、仮想環境上ならば、デバイスは仮想デバイスという形でVMM側から共通のインターフェースで与えられるので、仮想デバイス用のドライバさえつくってしまえばこの問題をクリアできます。<br>要するに、計算資源の仮想化をVMM側に完全に任せることで上に乗っかるOSはさほどがんばる必要がない、という考え方です。<br>このアプローチはかなり強力で、評価では起動時間・バイナリサイズを大幅に削減することが示されています。これはシステムコールが関数呼び出しとして実現できる・必要な関数のみリンクさせることでサイズを小さくできるなどによるものです。<br>MirageOSはOCamlで書かれていてGCのコストや型安全性の保障のためのオーバーヘッドがあるはずですが、それを上回るメリットがMirageOSの設計にはあったというわけです。</p>
<p>MirageOSには１つ大きな問題があり、それはアプリケーションをOCamlでMirageOS用に書き直さなければならない、ということです。<br>彼らの主張としては、今までの型安全ではない言語でかかれたシステムはバグを含んでいることがしばしばあるので、むしろ積極的に書き直すべきだという立場をとっています。<br>一理あるかもしれませんが、やはり何もかも今までの資産を切り捨てるというのは難しいのがUnikernelの課題としてありました。</p>
<p>Unikernelやそれに類似したシステムは今までいろいろと提案されてきました。<br>Usenix ATC ‘14で発表された<a href="https://www.usenix.org/node/184012" target="_blank" rel="noopener">OSv</a>では、Linux ABIを提供することでLinuxアプリケーションを動かしたり、JVMを提供したりと、より広く使われている言語をサポートしていますが、アプリケーションそのものは再ビルドする必要があります。<br><a href="http://rumpkernel.org/" target="_blank" rel="noopener">Rumpkernel</a>はNetBSDのデバイスドライバを抽出して、OSなしでもアプリケーションで使うことができるというものですが、これもアプリケーションは再ビルドする必要がありました。<br>つまりこれらの手法はソースコードが入手できることが前提のもので、コンパイル済みのバイナリはサポートできません。</p>
<p>Unikernelを用いたシステムとしては以前紹介した<a href="/hexo/2015/12/12/advent.html">Jitsu</a>や前回のLightVMの論文でもいくつか提案はされています。<br>Unikernelの小さいバイナリサイズ・実行オーバーヘッドの少なさがあってのシステムなのですが、アプリケーション構築のためのエンジニアリングコストをいかに小さくできるか、という課題があったわけです。<br>LightVMの論文ではTinyxというLinuxディストリビューションを必要最低限に小型化する方法が提案されていましたが、この形式ではUnikernelの恩恵はあまり得られず、論文でもこれは折衷案であるということを認めていました。</p>
<h2 id="提案手法：HermiTux"><a href="#提案手法：HermiTux" class="headerlink" title="提案手法：HermiTux"></a>提案手法：HermiTux</h2><p>彼らはこのアプリケーションの移植コストというものを減らすために、再ビルドなしで完全なLinuxでのバイナリコンパチビリティを保ちつつUnikernelの恩恵も得られるものという手法を提案しています。<br>提案手法のプロトタイプをHermiTuxと名付けています。これはHermitCoreというUnikernelをベースにつくられているからです。</p>
<p>HermiTuxはLinuxのABIのルールに従い、ロードおよびランタイムにエミュレートしてあげる必要があります。<br>ソースコードの入手を前提としていないため、Linuxシステムの呼び出しを事前に置き換えておいたり、違うライブラリをリンクすることはできません。<br>また、アプリケーションはライブラリを動的にも静的にもリンクしてある可能性があるので、その両方のパターンを考慮しなければなりません。<br>HermiTuxでは、uHyveという軽量なハイパーバイザをVMM上（今回はKVMを用いている）をまずは知らせ、その上でLinuxアプリケーションとHermiTuxのカーネルを動かしています。</p>
<p>ロードの仕方も論文には書かれていますが、Linuxシステムコールをどう処理するかが特におもしろかったので、今回はそこだけを見ていきます。<br>システムコールハンドラは通常であれば、特権レベルの切り替えが発生するのですが、HermiTuxではその必要がありません。そのため、その切り替えがない分、システムコールを速く処理できます。<br>しかし、呼び出しそのものはsyscall命令によって行われているため、普通の関数呼び出しとしてい実現される通常のUnikernelよりはどうしても遅くなってしまいます。動的にCライブラリがリンクされている場合は、Cライブラリそのものの中にあるシステムコールを予め関数呼び出しに置き換えることによりこの問題を回避できます。<br>Cライブラリ実装のひとつでであるMuslはシステムコールがマクロを経由して呼び出されているため、<a href="http://coccinelle.lip6.fr/" target="_blank" rel="noopener">Coccinelle</a>というコード変換ツールを使い自動的に置き換えられるとしています。</p>
<p>静的にリンクされている場合は、実行時にバイナリを置き換えるというテクニックを用いています。x86の命令は残念なことに可変長でsyscallは２バイト、通常の関数呼び出しであるcall命令は5バイトです。<br>そのため、syscall命令の次の命令までまとめて別のスニペットへのjmp命令として置き換えて、スニペット中で関数呼び出しと次の命令を実行して戻ってくるという方法で実現されています。</p>
<p>ひとつの問題として、システムコールの種類は非常に多く、すべてサポートするのは大変ということです。この研究でもすべてのシステムコールはサポートしきれていませんが、それでもいくつかのメジャーなアプリケーションをサポートできています。<br>システムコールのサポートを追加していくのは実装コストだけでなく、カーネルサイズの増大も引き起こします。そこでこの研究ではそれぞれのシステムコールをモジュール化し、必要なシステムコールのみをカーネルに含められるようにしています。<br>問題はアプリケーションがどのシステムコールを使うかです。straceなどのツールで実際にどのシステムコールが呼ばれるかを解析するのは、そのテスト実行のコードカバレッジに依存するため安全ではありません。<br>静的にライブラリがリンクされている場合、静的解析を行うことでかなりの部分を解析することができます。動的にリンクされる場合は、どのライブラリ関数が呼ばれているかを解析することにより、その関数から呼ばれているシステムコールを解析することにより特定することができます。<br>これらのテクニックにより大幅にカーネルサイズを減らせます。</p>
<p>また、HermiTux用のデバッガとプロファイラといった開発ツールのサポートも行われています。</p>
<h2 id="評価"><a href="#評価" class="headerlink" title="評価"></a>評価</h2><p>評価では、通常のLinux VM、Dockerコンテナ、OSv、Rumprunと各種ベンチマークを用いた比較を行っています。<br>ベンチマークにはLMbench、<a href="https://parsec.cs.princeton.edu/" target="_blank" rel="noopener">PARSEC</a>、redis、SQLiteなどが用いられています。<br>Hello Worldアプリケーションではバイナリサイズ・起動時間・メモリ使用量を大幅に減らせることが示されていて、他のベンチマークのパフォーマンスでもかなりの性能を示しています。</p>
<h2 id="まとめ・感想"><a href="#まとめ・感想" class="headerlink" title="まとめ・感想"></a>まとめ・感想</h2><p>Linuxアプリケーションをバイナリコンパチブルで動かせるHermiTuxの手法について解説しました。</p>
<p>Unikernelはかなり攻めた手法でなかなか実運用されているケースは聞かないですが、段々とその活用の仕方と移植コストの軽減策が出てきていて非常におもしろいですね。<br>将来、コンテナ型仮想化に代わる選択肢として広く使われることになるのか楽しみです。</p>
<p>Unikernelについてもっと掘り下げて知りたい方は、<a href="https://en.wikipedia.org/wiki/Unikernel" target="_blank" rel="noopener">Wikipedia（英語）</a>でも記事になっている他、こちらのQitta記事とかがいいかもしれません。</p>
<a href="https://qiita.com/t-imada/items/ed6a76f5b257f5608ad0" class="link-preview" target="_blank" rel="nofollow"><div class="link-area"><div class="og-image"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-9f5428127621718a910c8b63951390ad.png?ixlib=rb-4.0.0&w=1200&mark64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTkxNiZ0eHQ9VW5pa2VybmVsJUUzJTgxJUFBJUU2JTgzJTg1JUU1JUEwJUIxJTIwJTI4aW4lMjBKYXBhbmVzZSUyOSZ0eHQtY29sb3I9JTIzMjEyMTIxJnR4dC1mb250PUhpcmFnaW5vJTIwU2FucyUyMFc2JnR4dC1zaXplPTU2JnR4dC1jbGlwPWVsbGlwc2lzJnR4dC1hbGlnbj1sZWZ0JTJDdG9wJnM9MTNlZDg3OThkOWZlMDg1ODA4NjUzYzNmZDQwMjhlMzM&mark-x=142&mark-y=112&blend64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTYxNiZ0eHQ9JTQwdC1pbWFkYSZ0eHQtY29sb3I9JTIzMjEyMTIxJnR4dC1mb250PUhpcmFnaW5vJTIwU2FucyUyMFc2JnR4dC1zaXplPTM2JnR4dC1hbGlnbj1sZWZ0JTJDdG9wJnM9NGZjYTU5MTE2MGQ5NGQ3N2M1OTczYzBhZGU0MWEwM2E&blend-x=142&blend-y=491&blend-mode=normal&s=56e752f10ef51ac0a995196a9a08ee3b"></div><div class="descriptions"><div class="og-title">Unikernelな情報 (in Japanese) - Qiita</div><div class="og-description">

はじめに

「Unikernelって知ってますか!?」という質問を日本で(というか海外でも)聞くとだいたい「知らない」と冷たい回答が返ってくるので、啓蒙活動の一環としてこの記事を書いてみることにしました。

サーバ仮想化用ハイパバ...</div></div></div></a>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-29T15:00:00.000Z"><a href="/hexo/2019/06/30/lightvm.html">2019-06-30</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/06/30/lightvm.html">論文紹介：My VM is Lighter (and Safer) than your Container</a></h1>
  

    </header>
    <div class="entry">
      
        <p>元論文: <a href="https://dl.acm.org/citation.cfm?id=3132763" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=3132763</a></p>
<p>VM（仮想マシン）をたくさん立ち上げたいとき、VMM（仮想マシンモニタ、ハイパーバイザ）のどういうところがボトルネックになるかを分析した上で、VMMを改善し、Unikernelを用いてコンテナシステムより軽量で（かつセキュアな）システムを構築しました、というような話です。</p>
<h2 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h2><ul>
<li>タイトル：My VM is Lighter (and Safer) than your Container</li>
<li>著者：Filipe Manco, Costin Lupu, Florian Schmidt　et. al.</li>
<li>会議：Proceedings of the 26th Symposium on Operating Systems Principles (SOSP ‘17)</li>
</ul>
<p>システム系のトップカンファレンスとしておなじみのSOSPで発表された論文です。<br>著者はNEC Laboratories Europeとブカレスト工科大学（ルーマニアの大学）の所属の方々です。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>DockerやLXCのような軽量な仮想化はひとつのトレンドになっている。例えばGoogleでは自社のサービスを全てコンテナ化して動かしており、Container as a Service（CaaS）としてAmazonやMicrosoftのAzureもコンテナプラットフォームを提供している。<br>コンテナ型仮想化はXenやKVMのようなハードウェアレベルの仮想化に比べると起動が早く、インスタンスごとのメモリ使用量も少なくてすみ、１つのホストによりたくさんのインスタンスを立ち上げられる。<br>しかし、コンテナ型仮想化ではインスタンスはホストOSから400以上ものsyscallのAPIを与えられ、それらをセキュアに保つのは難しい。これらのAPIを利用することでインスタンスがリソースを大量に消費するようなDoS攻撃を他のインスタンスに対してしかけることも考えられる。<br>そのため、複数のユーザーが存在するような状況ではコンテナ型仮想化を使うことはセキュリティ上の懸念から難しい。</p>
<h2 id="研究の要求仕様"><a href="#研究の要求仕様" class="headerlink" title="研究の要求仕様"></a>研究の要求仕様</h2><p>彼らは既存のハードウェアレベル仮想化のVMMのボトルネックを分析した上で、LightVMという軽量なType-1のハイパーバイザ（XenのようにOSを介在することなくハードウェア上で直接動くVMM）を開発した。<br>ゴールとしてコンテナのような軽量性を目指していて、具体的な仕様としては</p>
<ul>
<li>インスタンスの高速な起動</li>
<li>大量のインスタンスが建てられること（メモリ使用量とインスタンスイメージのサイズが小さい）</li>
<li>インスタンスの一時停止と再開が高速にできる</li>
</ul>
<p>ということを掲げている。</p>
<h2 id="軽量なVM"><a href="#軽量なVM" class="headerlink" title="軽量なVM"></a>軽量なVM</h2><p>まず第一にVMそのものが軽量である必要がある。多くの場合、VM（ないしコンテナ）は1つのアプリケーションのみを動かすことが多い。<br>そこに注目することで、VMに含まれる機能を削れば軽量なVMをつくることができる。<br>有名な既存研究としてはUnikernelが存在する（参考：<a href="http://anil.recoil.org/papers/2013-asplos-mirage.pdf" target="_blank" rel="noopener">Unikernels: Library Operating Systems for the Cloud</a>）。<br>これはOSをライブラリ化してしまい、対象アプリケーションに直接リンクさせることにより、非常に小さいVMをつくるというものである。<br>OSの機能をシングルアプリケーションを動かすことに特化させられ必要な機能のみをリンクするので強力なアプローチである一方、<br>Unikernelが提供するAPIはLinuxなどの既存のAPIとは互換性がないため、多くの場合、既存のアプリケーションをそのまま動かすのは非常に難しい。</p>
<p>もう一つの軽量なVMをつくる方法として、Tinyxが存在する。<br>これは特定のアプリケーションを動かすことに特化したLinuxディストリビューションを自動的にビルドするというツールだ。<br>この研究ではこの２種類のVMと通常のLinuxのVMを使い各種実験を行っている。</p>
<h2 id="既存のVMMのボトルネック"><a href="#既存のVMMのボトルネック" class="headerlink" title="既存のVMMのボトルネック"></a>既存のVMMのボトルネック</h2><p>この研究では著名なType-1ハイパーバイザであるXenを分析して、大量のインスタンスを立ち上げた時のボトルネックを調べている。<br>まず、1000のVMを立ち上げる、という実験をしている。全てのVMは起動後アイドル状態になるようにしてインスタンスが増えてもリソースを消費しないようにしたにもかかわらず、起動時間がインスタンスが増えるに従い激減していることがまずわかった（VMはDebian、Tinyx、Unikernelそれぞれで試している）。<br>原因はXenStoreというVMの情報を管理するツールに自身の情報を登録するフェーズにあることがわかった。</p>
<p>そこで彼らのLightVMではXenStoreを使わず<code>noxs</code>という新たなVM・VMM間のコミュニケーションを共有メモリを介して行うアーキテクチャを設計した。<br>また、<code>xl/libxl</code>の代わりとして<code>chaos/libchaos</code>というツールスタックも実装した。<br>XenではVM起動時にVM側のデバイス側のインターフェースを初期化するにはまず、dom0がデバイスのバックエンドからイベントチャンネルなどの必要な情報を取り出し、それをXenStoreに格納する。<br>その後、VM側はXenStoreに問い合わせることによってそれらの情報を取り出す。このXenStoreとのインタラクションは頻繁に発生し起動が遅くなる原因となる。<br>LightVMではdom0がバックエンドから取り出した必要な情報をハイパーバイザ内のページに格納する。その後、VM側でハイパーコールを使うことでそれらの情報を取り出しVM側で情報を持つようにする。<br>その後、デバイスのバックエンドとのやり取りはイベントチャンネル介し直接やり取りできるようになる。</p>
<p>また、彼らは同じようなVM作成時に実行されるコマンドのうち多くは、VM作成前に実行できるということに注目した（例えば同じメモリ容量を割り当てるVMであれば事前にメモリをアロケートしておく）。<br>そこで、libchaosでは作成時のフェーズをprepareとexecuteという2つのフェーズに分け、prepareはVM作成コマンドが発行される前に予め行っておき、VM作成のための土台をプールしておく。<br>VM作成コマンドが実行されると、そのプールから土台を持ってきて、そのVMのためにコンフィギュレーションをチェックした上で実際にVMを起動させる。</p>
<h2 id="評価"><a href="#評価" class="headerlink" title="評価"></a>評価</h2><p>Dockerとブートタイム、マイグレーション、メモリ使用量などを比較している。詳細は割愛するが、Docker並のパフォーマンスが実現できている。</p>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Xenのボトルネックを詳細に分析した上で、LightVMという新しいアーキテクチャのVMMを設計し、Dockerにもひけを取らない軽量な仮想化フレームワークを構築した。<br>ユースケースとしては、モバイルエッジコンピューティング（クラウド上ではなくモバイル端末にプロセスを直接走らせる）やAmazon Lambdaのような短時間の計算リソース提供サービスなどが考えられる。<br>この研究ではXenをターゲットとしたが、KVMなど他のVMMでもこの手法は使えるだろうと論文では主張している。<br>また、用いるVMとしてUnikernelはアプリケーション移植のエンジニアリングコストが高く、Tinyxは通常のLinuxのVMよりはパフォーマンスがいいが、Unikernelほどではなない。<br>そのような面からDocker並の使いやすさはまだ備えていない。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-05-14T15:00:00.000Z"><a href="/hexo/2019/05/15/erkos.html">2019-05-15</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/05/15/erkos.html">Rustで自作組込みOSを書くプロジェクト「ErkOS」を公開しました</a></h1>
  

    </header>
    <div class="entry">
      
        <p>だいぶ前からRustでOSを書こうとしていて、ようやく一山越えて形になってきたのでレポジトリを公開しました（気まぐれでまた非公開にするかもしれませんが）。</p>
<a href="https://github.com/garasubo/erkos" class="link-preview" target="_blank" rel="nofollow"><div class="link-area"><div class="og-image"><img src="https://opengraph.githubassets.com/9b9cbc7f9ccd00d9e157d7adb6da8477323b73730f83ff8f2c34abe4412a5048/garasubo/erkos"></div><div class="descriptions"><div class="og-title">GitHub - garasubo/erkos: A prototype embedded operating system written in Rust</div><div class="og-description">A prototype embedded operating system written in Rust - GitHub - garasubo/erkos: A prototype embedded operating system written in Rust</div></div></div></a>

<h2 id="構造"><a href="#構造" class="headerlink" title="構造"></a>構造</h2><p><code>app</code>ディレクトリに実際のボードで動かしているデモが入っています。ボードはNucleo-F429ZIを利用しています。<br><code>qemu_app</code>はqemu用のデモです。<br>nightlyコンパイラと必要なツールチェーンをインストールすれば<code>cargo build</code>でコンパイルでき、qemuのデモは<code>cargo run</code>とすれば動くと思います。</p>
<p><code>kernel</code>モジュールがスケジューラだったり、プロセスなどのOSの機能を実装したものになっています、<br><code>arch</code>がARMv7-M固有の機能のためのライブラリ（NVICやSystickなどもこちら）、<code>device</code>はボード固有のペリフェラルドライバとなっています。<br><code>rt</code>と<code>log</code>は<a href="https://docs.rust-embedded.org/embedonomicon/" target="_blank" rel="noopener">The Embedonomicon</a>のチュートリアルでつくったモジュールに手を加えたものです。<br><code>util</code>はアーキテクチャやボードに依存しない機能を入れるためのモジュールです。</p>
<p>機能としては</p>
<ul>
<li>スレッドモードで動くプロセスをラウンドロビンスケジューラでスケジュールできる<ul>
<li>10ms毎のSystick割り込みでプロセスが切り替わる</li>
</ul>
</li>
<li>プロセスからSVC命令でカーネルの機能を呼び出せる<ul>
<li>シリアルをつかったprint命令</li>
<li>プロセス自身を特定のIRQが呼び出されるまでスケジュールされないようにする命令</li>
</ul>
</li>
<li>実行するプロセスがない場合は割り込み待ちのスリープ状態に遷移する<br>あたりが実装できました。こうしてみるとまだまだ機能は足りないですが、おおよその骨格は出来上がってきたのかなあと思ってます。</li>
</ul>
<h2 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h2><p>異なる種類のボードで動かすことを想定して、コアとなる機能を実装した<code>kernel</code>モジュールはボード固有の機能に依存しないように気を配りました。また、スケジューラも地味に独立したモジュールにしました。これは将来、スケジューリングポリシをユーザーが選べるようにするのを目標にしたからです（以前つくった<a href="/hexo/2016/05/23/t-visor.html">T-Visor</a>でも同じようなことを目指しました）。<br>本当はアーキテクチャとの依存性もなくし、Arm以外のアーキテクチャへの対応もできるようにしたかったのですが、とりあえずは諦めました。</p>
<p>ペリフェラルのインターフェースは当初はできるだけRust Embeddedチームの成果物を使う予定でした。svd2rustやcortex-mのクレートはよくできていて、これらを使うことでペリフェラルを簡単に扱ういい感じのインターフェースができます。<br>しかし前に述べたように、独自のモジュールを使っています。これはsvd2rustなどの方針として、ペリフェラルを触るためのインターフェースが実行時にシングルトン化されています。また、各々のインターフェースは実行時にしか取得できません。<br>これがかなり問題で、割り込みハンドラとmain関数で両方でデバイスを触りたい、といった時にどのように共有させるかというのが問題になります。no_std環境のため、MutexやArcといったものは使えないのも厳しいです。一応、Option型のグローバル変数として共有すればいいのですが、unsafeで囲ってnullチェックもしなければならない、とそれなりにめんどくさいです。<br>もちろん、むやみやたらにインターフェースを共有するのもそれはそれでよくないのですが、とりあえず動くものを書きたかったのと、自分の勉強にもなるだろうということで自前のものを使う、という判断にしました。</p>
<p>Rustはテストのシステムもあるのですが、テストはstdに依存しているためそのままでは実行できません。そこで、<a href="https://os.phil-opp.com/testing/" target="_blank" rel="noopener">Writing an OS in RustのTesting</a>を参考にQEMUを利用してテストが走る環境をつくりました。<br>しかしながら、やはりアーキテクチャやペリフェラルに直接関わるテストはどう書けばいいのか思いつかず、現状QEMUを利用するテストはないです。<br>代わりに、<code>util</code>はstd環境でも動くようにアーキテクチャへの依存を切って普通にテストを書きました。</p>
<h2 id="今後の展望"><a href="#今後の展望" class="headerlink" title="今後の展望"></a>今後の展望</h2><p>まだまだ機能が足りていないなあという感じです。とりあえず今やりたいと思っていることは</p>
<ul>
<li>ヒープ領域が存在しないのでallocを実装する</li>
<li>プロセス間の通信</li>
<li>優先度を考慮したスケジューリング</li>
<li>ペリフェラルドライバの充実</li>
</ul>
<p>その他、他のボードやアーキテクチャへの移植もゆくゆくはやっていきたいですね</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-24T15:00:00.000Z"><a href="/hexo/2019/04/25/rust-lt.html">2019-04-25</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/04/25/rust-lt.html">Rust LT会</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://rust.connpass.com/event/125666/" target="_blank" rel="noopener">Rust LT会 #4</a>にLT登壇枠で参加してきました。<br>この会に参加するのははじめてなので少々ためらったのですが、LT枠が結構余っていたのと、たまにはこういう場で発表して自身のモチベーションあげようということで、簡単ではありましたが、低レイヤープログラミングについての話をしました。</p>
<p><a href="https://garasubo.github.io/rustlt4/">発表スライド</a></p>
<p>発表時間には間に合ったものの、会の開始時間には遅刻してしまい運営の方々にはご迷惑をおかけしました。<br>登壇枠で参加するときは特に時間に余裕を持たなければ…</p>
<h2 id="ちょっとした補足"><a href="#ちょっとした補足" class="headerlink" title="ちょっとした補足"></a>ちょっとした補足</h2><p>いくつか会場で出た質問とか、スライドでは深く突っ込んでいない内容についてちょっとした補足をしておきます</p>
<h3 id="no-stdプログラミングでのクレート"><a href="#no-stdプログラミングでのクレート" class="headerlink" title="no_stdプログラミングでのクレート"></a>no_stdプログラミングでのクレート</h3><p>低レイヤープログラミングでは基本的にはstdクレートは使えないため、stdクレートに依存している大半のクレートは使用できません。<br>しかし、中にはno_stdでつくられているものもあり、そういうものは<a href="https://rust-embedded.github.io/book/intro/no-std.html" target="_blank" rel="noopener">crate.ioでno_stdキーワードがついています</a>。 
が、たとえno_stdでつかえるものでも作者がキーワードを設定していないことも多いです…</p>
<p>追記：<a href="https://crates.io/categories/no-std" target="_blank" rel="noopener">no_stdというカテゴリーをつけるほうが一般的っぽい</a></p>
<p>それでも個人的にはクレートシステムの存在はありがたく、すでに様々な便利なクレートの存在のおかげで、低レイヤープログラミングといえどもフルスクラッチで書くのを避けることもできます。<br>C言語などではデファクトといえるこういうシステムがなかったのでありがたいと思っています。</p>
<h3 id="Redoxについて"><a href="#Redoxについて" class="headerlink" title="Redoxについて"></a>Redoxについて</h3><p><a href="https://gitlab.redox-os.org/redox-os/rust" target="_blank" rel="noopener">Redoxのレポジトリ</a>を見ればわかるのですが、なんとRustコンパイラのフォークをサブモジュールとしてとりこんでいます。<br>どこを変更したかは具体的には追えていないのですが、所有権に関する制約を緩和するためにRustコンパイラを変更する必要があったという記述をどこかで見た記憶があります。<br>Rustコンパイラそのものをビルドする必要があるので、Redox全体のビルドは結構大変です。dockerイメージが同梱されているので、そちらを利用するといいでしょう。</p>
<p>一方で、このブログでも何度か登場したTockはnightlyコンパイラでビルドでき、発表された論文ではその部分が貢献のひとつとして強調されていました。<br>TockはRustで書かれているという以外にも、組込みOSの設計として面白いアーキテクチャをしているので、興味があれば是非みてみるといいと思います。</p>
<h2 id="スライドについて"><a href="#スライドについて" class="headerlink" title="スライドについて"></a>スライドについて</h2><p><a href="http://jedcn.github.io/reveal-ck/" target="_blank" rel="noopener">reveal-ck</a>というのを使ってつくりました。<br>いつもならばPowerPointかGoogle Docsでつくるのですが、markdown形式でつくれてウェブページとして公開できるのはいいかも、と思い試験的に使ってみました。<br>しかし、スライドの文字の位置や大きさをもっと調整したかったとかを考えると、やはりPower Pointとかでつくったほうがいいのかも、というのが正直な感想です。<br>また次回、LT会等の機会があったら別のシステムもいろいろ検討したいと思います。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-04-16T15:00:00.000Z"><a href="/hexo/2019/04/17/cortexm-mode.html">2019-04-17</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/04/17/cortexm-mode.html">ARMv7-Mで動作モードを利用してコンテキストスイッチ</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Cortex-M4のボードで自作OSに挑戦している。<br>Cortex-M4の準拠するARMv7-Mアーキテクチャでは２つの「動作モード」（Operating Mode）が存在する。</p>
<ul>
<li>スレッドモード</li>
<li>ハンドラモード</li>
</ul>
<p>リセット状態ではスレッドモードで、割り込みが発生するとハンドラモードに移行して割り込みハンドラが実行される。<br>スレッドモードは特権が存在し、特権・非特権の２つの状態があり、リセット状態では特権状態である。ハンドラモードでは常に特権状態となる。<br>特権の状態を切り替えるにはハンドラモードに突入してから切り替える、もしくは特権状態ならばCONTROLレジスタに書き込むことで非特権状態になれる。</p>
<p>この特権の状態を利用することで、カーネル（スケジューラ）部分は特権状態で動かして、通常のプロセスに相当する部分は非特権状態で動かすということができる。<br>では、どうやってリセット状態からプロセスを起動するか。<br>ARMv7-Mでは割り込みが発生するとスタックポインタに自動的に一部のレジスタ状態をプッシュし、<br>ハンドラモードからの復帰時にスタックポインタに保存されたレジスタを復元する。<br>スタックポインタはメインとプロセスの2種類あり、通常のスレッドモードでは、特権状態ではメインを、非特権状態ではプロセスを使う。<br>つまりプロセスを初期状態から起動させるには</p>
<ol>
<li>プロセススタックポインタにプロセスの初期状態をプッシュしておく</li>
<li>svc命令でSVCの割り込みハンドラをハンドラモードで実行</li>
<li>ハンドラから非特権状態のスレッドモードに復帰</li>
<li>プロセスが起動される</li>
</ol>
<p>という流れになる。</p>
<p>注意するべき点としては</p>
<ul>
<li>浮動小数点の機能が有効化されている場合はより多くの状態を保存するため、スタックのフレームサイズが代わる</li>
<li>スタックはCCR.STKALIGNがセットされていない場合は4バイトに、セットされている場合は8バイトにアラインされている必要がある</li>
<li>xPSRレジスタのうちThumbモードを有効にするビットは立てる必要がある（ARMv7-Mでは常にThumbモードで実行されなければならない）。よって初期値は0x01000000である必要がある</li>
<li>スタックに保存されないレジスタに関しては別途なんらかの手段で保存しておかないと複数プロセス間の切り替えができない</li>
</ul>
<p>細かい動作はリファレンスマニュアルを参照すること。以下に自分が参考にした章を示す（マニュアルのバージョンはE.b）</p>
<ul>
<li>B1.3 Overview of system level terminology and operation<ul>
<li>動作モードの定義</li>
</ul>
</li>
<li>B1.4.2 The special-purpose program status registers, xPSR<ul>
<li>xPSRレジスタの詳細</li>
</ul>
</li>
<li>B1.5.6 Exception entry behavior<ul>
<li>例外発生時の動作について。スタックのレイアウトについても書かれている</li>
</ul>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-30T12:48:35.000Z"><a href="/hexo/2019/03/30/rust-uefi.html">2019-03-30</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/03/30/rust-uefi.html">UEFIアプリケーションをRustで書く（外部クレートなし）</a></h1>
  

    </header>
    <div class="entry">
      
        <p>このあいだのRustのアップデートで、<code>x86_64-unknown-uefi</code>なるターゲットが追加された、と聞いてRustでUEFIプログラミングに挑戦しました。<br>なお、世の中にはすでに<a href="https://github.com/rust-osdev/uefi-rs" target="_blank" rel="noopener">uefi-rs</a>というものが用意されているので、もっと簡単にUEFIアプリケーションを書くことができます。<br>ただ、このクレートの構造の説明みたいなのがドキュメントとして見当たらず、今までUEFIを触ったことがなかったので、せっかくなのでこのクレートも含め外部クレートなしでのプログラミングをしました。</p>
<h2 id="UEFIとは"><a href="#UEFIとは" class="headerlink" title="UEFIとは"></a>UEFIとは</h2><p>BIOSに代わるファームウェアに対するソフトウェアインターフェースのこと。詳しくは<a href="https://ja.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface" target="_blank" rel="noopener">Wikipedia</a>ないし、C言語を使っての開発についてはもっと多くの先例があるのでそちらを参考にすればいいと思われる。</p>
<ul>
<li><a href="https://qiita.com/tnishinaga/items/40755f414557faf45dcb" target="_blank" rel="noopener">gnu-efiでUEFI遊びをはじめよう - Qiita</a></li>
<li><a href="http://d.hatena.ne.jp/shina_ecc/20140819/1408434995" target="_blank" rel="noopener">ツールキットを使わずに UEFI アプリケーションの Hello World! を作る - 品川高廣（東京大学）のブログ</a></li>
<li><a href="http://yuma.ohgami.jp/UEFI-Bare-Metal-Programming/" target="_blank" rel="noopener">フルスクラッチで作る!UEFIベアメタルプログラミング</a></li>
</ul>
<p>最新の仕様は直接仕様書を見て確認しましょう。今回はversion 2.7に準拠。<br><a href="https://uefi.org/specifications" target="_blank" rel="noopener">Unified Extensible Firmware Interface Forum</a></p>
<h2 id="準備"><a href="#準備" class="headerlink" title="準備"></a>準備</h2><p>今回はx86_64のUEFIアプリケーションをつくります。<br>まず、x86_64ターゲットが追加されているRustを使う必要があります。また、ターゲットは追加されたものの、標準ライブラリ(stdではなくcoreとか)がまだ整えられていないのでstableではなくnightlyを使う必要があります。<br>更に、標準ライブラリを組み込むため<a href="https://github.com/rust-osdev/cargo-xbuild" target="_blank" rel="noopener">cargo-xbuild</a>も使う必要があります</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rustup<span class="built_in"> default </span>nightly-2019-03-23</span><br><span class="line">$ cargo install cargo-xbuild</span><br></pre></td></tr></table></figure>

<p>また、実行環境としてqemu-system-x86_64とqemu用のUEFIファームウェアである<a href="https://github.com/tianocore/tianocore.github.io/wiki/OVMF" target="_blank" rel="noopener">OVMF</a>が必要です。<br>自前でビルドする方法はやってみたのですが、途中で詰まってしまったし、めちゃくちゃ時間もかかるのでビルド済みのものをとってきたほうが早いでしょう<br><a href="https://www.kraxel.org/repos/" target="_blank" rel="noopener">https://www.kraxel.org/repos/</a>からjenkins/edk2以下にあるx64用のrpmをとってきてその中にあるOVMF_VARS-pure-efi.fdとOVMF_CODE-pure-efi.fdをとってきました。</p>
<h2 id="できたもの"><a href="#できたもの" class="headerlink" title="できたもの"></a>できたもの</h2><p>Githubに置いておきました。<br><a href="https://github.com/garasubo/uefi-practice" target="_blank" rel="noopener">garasubo/uefi-practice</a><br><code>cargo xbuild --target x86_64-unknown-uefi</code>としてビルドし、qemu-run.shでqemu上で走らせます。ただし、OVMF_VARS.fdとOVMF_CODE.fdをプロジェクトのルートディレクトリに置いておく必要があります。</p>
<p>qemu-run.shを実行するとuefiシェルが立ち上がるので</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Shell</span><span class="bash"> &gt; fs0:</span></span><br><span class="line"><span class="bash">FS0: \&gt; uefi-practice.efi</span></span><br></pre></td></tr></table></figure>

<p>とすると、画面がクリアされた後、Hello Worldします</p>
<h2 id="解説"><a href="#解説" class="headerlink" title="解説"></a>解説</h2><p><code>efi_main</code>関数がエントリポイントになっています。仕様書で言うと<code>EFI_IMAGE_ENTRY_POINT</code>に相当します。<br>仕様書にはC言語での型宣言が書かれているのですが、これをRustで書いていくことになります。<br>普通にstructやenumを宣言してしまうとRust独自のABIでコンパイルされてしまうので、<code>repr</code>をつけて互換性を保ちます。詳しくはThe Rustonomiconの<a href="https://doc.rust-lang.org/nomicon/data.html" target="_blank" rel="noopener">Data Layoutの章</a>が参考になります。<br>今回の目標はhello worldすることなのですが、UEFIのテキストを出力するためのインターフェースを利用します。<br>仕様書で言うと<code>EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</code>です。<br>僕のコードではreset関数とoutput_string関数が定義されていますが、本当はもっとあります。<br>他のstructについても今回は使う部分だけ型宣言をして残りはサボりました。使わない関数はusizeでごまかしました。全部実装するのはしんどい。</p>
<p>output_stringはPROTOCOL自体へのポインタと文字列への先頭ポインタを渡す必要があります。この文字列が少々やっかいでUCS-2でエンコーディングされていないといけません。<br>RustはUTF-8で文字列を扱っているため、1文字が16ビットのUCS-2に変換するのは標準ライブラリだけで簡単にやってくれそうではなかったので、<br>適当なバッファを用意して、実行時に無理やり16ビット配列に変換しました(uefi-rsも内部ではそうやっていた)。</p>
<p>あとは<code>no_std</code>では<code>panic_handler</code>は自前で用意しなければならないのでそれも忘れずに。</p>
<h2 id="疑問点"><a href="#疑問点" class="headerlink" title="疑問点"></a>疑問点</h2><p>uefi-rsを参考にしながらつくったのだが、<code>extern &quot;C&quot;</code>と<code>extren &quot;win64&quot;</code>の両方が出てくることがあり、これの違いについてはよくわからなかった。<br>とりあえずuefi-rsに従いこれらの宣言をつけておいたが、本当は<code>extern &quot;C&quot;</code>としておいても問題ないかも？</p>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>UEFIの仕様は真面目に実装するのは大変なので、おとなしくuefi-rsを使いましょう</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-03-19T15:00:00.000Z"><a href="/hexo/2019/03/20/go-kernel.html">2019-03-20</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/03/20/go-kernel.html">論文紹介：The benefits and costs of writing a POSIX kernel in a high-level language</a></h1>
  

    </header>
    <div class="entry">
      
        <p>元論文: <a href="https://www.usenix.org/conference/osdi18/presentation/cutler" target="_blank" rel="noopener">https://www.usenix.org/conference/osdi18/presentation/cutler</a></p>
<p>Go言語でPOSIXインターフェースを備えたカーネルを実装し、その利点と欠点を比較してみた、という論文です。</p>
<h2 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h2><ul>
<li>タイトル：The benefits and costs of writing a POSIX kernel in a high-level language</li>
<li>著者：Cody Cutler, M. Frans Kaashoek, and Robert T. Morris (MIT CSAIL)</li>
<li>会議：13th USENIX Symposium on Operating Systems Design and Implementation (OSDI ‘18)</li>
</ul>
<p>去年のUSENIX OSDIで発表された論文です。USENIXはハイレベルな低レイヤー関連の会議が多く、かつ論文をオープンアクセスで提供してくれるのはアカデミアから離れた身としてはうれしい限りです。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>著名なOSのカーネルはC言語で書かれている。C言語は直接メモリを操作したり、デバイスのレジスタを操作したりできる。また、ランタイムを介さないためパフォーマンスも高い。一方、安全なコードを書くことが難しく、バッファーオーバーフローやuse-after-freeのようなバグの温床ともなりうる。<br>Go言語などの高級言語は、型検査やメモリの安全性がC言語よりも強く保証されるものの、多くの場合はランタイムを介しての実行となり、ガベージコレクション（GC)に頼るため、パフォーマンスへの懸念が生じる。<br>そこで彼らはBiscuitと名付けたPOSIXのサブセットを備えたカーネルをx86_64プロセッサ用に実装し、評価を行った。</p>
<p>この論文はカーネルの実装にC言語が用いられるべきか、高級言語が用いられるか、という主張をするものではなく、あくまで高級言語を用いた実装がどのようなものかという指標を提供するものだと著者らは位置づけている</p>
<h2 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h2><p>Go言語とアセンブラのみで書かれていて、C言語は全く用いていない。<br>Biscuitを動かすにはGo言語を動かすためのランタイムが必要で、通常であればランタイムはカーネルの機能を呼び出す。<br>今回は呼び出すカーネルがないので、代わりの機能を提供するShimというレイヤーを用意している。<br>Goのランタイムは標準のものにGCのタイミングを調整するなどの変更を加えたものを使用している。</p>
<p>割り込み対応、マルチプロセス、ファイルシステム、ネットワークスタックなどPOSIXのカーネルなら備えている機能はおおよそされている。</p>
<h2 id="GCとヒープ枯渇問題"><a href="#GCとヒープ枯渇問題" class="headerlink" title="GCとヒープ枯渇問題"></a>GCとヒープ枯渇問題</h2><p>Goはmark-and-sweep方式のGCを持っていて、確保していたメモリがある程度使われるとヒープ領域を適宜拡大していくということをしている。<br>Biscuitではこの通常のヒープ領域拡大を無効化して独自のタイミングでヒープ枯渇問題を回避している。<br>ヒープ領域が足りなくなったとき、Biscuitは</p>
<ol>
<li>キャッシュやソフトステイトのような保持する必要のないものを解放する</li>
<li>システムコールが消費するであろうヒープ領域のサイズをあらかじめ確保しておく</li>
<li>キラースレッドにより異常にヒープ領域を消費しているプロセスを殺す<br>ということをしている</li>
</ol>
<p>システムコールの消費するヒープの量を計算するためにMAXLIVEというツールを開発し、静的解析により事前に必要なヒープの量を計算している。<br>コールグラフからアロケーションの量を計算していくのが基本だが、ループによる繰り返し処理がからんでくるとアノテーションをつけることでヒントを与えたり、例外的な処理をして回避したりしている。</p>
<h2 id="評価"><a href="#評価" class="headerlink" title="評価"></a>評価</h2><p>この研究では高級言語をカーネルの実装に用いることでの利点・欠点を具体化するのが目的なので、評価軸もそれに沿ったものになっている。</p>
<p>まずそもそも高級言語の機能がどれくらい用いられているのか、というのを他のGoで書かれたソフトウェアとの比較を行っている。<br>GoのコンパイラとMoby（Dockerがつくったコンテナを用いたシステムのフレームワーク）と比較して同じくらいだとしている。<br>GCで管理されるオブジェクトが有用な場面とそうでない場面もある、と具体例も上げている。<br>有用な例としてはpollのシステムコールでは入力待ちのスレッドを起こすためのヘルパーオブジェクトのを挿入するが、そのヘルパーオブジェクトのフリーのタイミングを気にしなくても競合が起きないことをあげている。<br>一方、TCPのコネクションオブジェクトはTCPのシャットダウンプロトコルを実行することが必要だが、Goのfinalizerではオブジェクト間の循環ができないためそのままでは難しいので、そのようなオブジェクトに対してはBiscuit自身が参照カウントを管理している。<br>また、LinuxのCVEを参照し、Use-after-freeやOut-of-boundsなどのGoでは脆弱性になりえないものとそうでないものを分類している。65個の深刻な脆弱性のうち40個はGoなら防げるとしている。<br>一方、Goのランタイムやパッケージ自体にも14のCVEが報告されて、うち4つはカーネルにとって深刻な脆弱性になりうるとしている。</p>
<p>アプリケーションベンチマークとしては、CMailbench（メールサーバーをモデルとしたforkとexecにより仮想メモリシステムへのストレス試験）、NGINX、Redisを実際に動かし、Linuxとの比較、ヒープサイズと使用メモリ割合に対するパフォーマンスなどの実験を行っている。</p>
<h2 id="関連研究"><a href="#関連研究" class="headerlink" title="関連研究"></a>関連研究</h2><p>カーネルの実装に高級言語を用いる例は様々ある。<a href="2018/05/23/tock.html">以前ここでも紹介したRust製カーネルのTock</a>も一例として挙げられている。<br>しかし、これらの研究はC言語との比較というよりも、新しいコンセプトのOSということに重きを置いている。<br>カーネル用に既存の言語を改変して用いるというものもあるが、この研究ではGoそのものに大きな変更は加えないようにしている。</p>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>Go言語を用いてBiscuitと名付けたPOSIXカーネルを実装し、C言語を用いた場合との比較を行った。<br>高級言語のもたらすパフォーマンス低下は15％を下回るとした一方、だからといってGoを使うべきだと結論づけてはいない。<br>しかし、Go言語でカーネルを実装する際の恩恵やコストを明らかにし、Goのような高級言語を使うべきか否かの判断材料になるであろうとしている</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-02-17T15:00:00.000Z"><a href="/hexo/2019/02/18/tockapp.html">2019-02-18</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/02/18/tockapp.html">Rust製組込みOS TockでC言語アプリケーションを動かす</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Tockとは"><a href="#Tockとは" class="headerlink" title="Tockとは"></a>Tockとは</h2><p>このブログでも何度か紹介したRust製組込みOSです。<br><a href="/hexo/2018/05/23/tock.html">以前の記事</a><br>ターゲットはCortex-MのようなCPUリソースが限られたようなプロセッサです。<br>Rust Embeddedグループ発足前から公開されていて、Rust純粋でちゃんとしたOSを組む先駆けにもなっています。Rustで書かれているだけでなく、組込みOSの設計としてもおもしろいものになっています。<br>以前は専用ボードへの実装しか公開されていなかったのですが、最近になりSTM社製のNUCLEO-446REボードのサポートが追加されました。<br>手元にあったNUCLEO−429ZIボード用のサポートも追加してもらえるようPRを投げ、無事マージされたことにより、自分の手元でも動かせるようになりました。</p>
<p>このTockの性質として、ユーザーアプリケーションは独立にビルドする仕組みとなっているため、任意の言語で書くことができるというものがあります。<br>今回はC言語を用いて簡単なアプリケーションを書いてみて、さらにその仕組みを簡単に見ていきたいと思います。</p>
<h2 id="サンプルアプリケーション"><a href="#サンプルアプリケーション" class="headerlink" title="サンプルアプリケーション"></a>サンプルアプリケーション</h2><p><a href="https://github.com/tock/libtock-c" target="_blank" rel="noopener">libtock-c</a>というライブラリがTockのカーネルを叩くための各種関数を提供しています。<br>これを用いて簡単なアプリケーションを書いてみました</p>
<p><a href="https://github.com/garasubo/tockapp" target="_blank" rel="noopener">garasubo/tockapp</a></p>
<p>このアプリケーションはキーボードの入力を受けるとLチカが動き出し、もう一度入力を受けると止まる、というものになっています。<br>サンプルアプリケーションのレポジトリではlibtock-cをgitのサブモジュールとして取り込んで、ビルドはlibtock-c内のAppMakefile.mkに全面的に依存しています。</p>
<p>libtock-cのレポジトリ自体にもサンプルコードがあります。<br>今回のサンプルでは使っていないのですが、Newlibによって実装されたC標準ライブラリやluaのランタイムもあります。</p>
<h2 id="ブートプロセス"><a href="#ブートプロセス" class="headerlink" title="ブートプロセス"></a>ブートプロセス</h2><p>サンプルアプリケーションでは普通にmain関数を書いているわけですが、これがTock側からどう呼ばれているかを見てみましょう。<br>リンカスクリプトがlibtock-cのuserland_generic.ldにあります。まずは、アプリケーションがどのようにビルドされるか見てみましょう。</p>
<a href="https://github.com/tock/libtock-c/blob/master/userland_generic.ld" title="userland_generic.ld" target="_blank" rel="noopener">userland_generic.ld</a>

<p>11行目、<code>ENTRY(_start)</code>となっていますが、これは<code>libtock/crt0.c</code>に定義されています。26行目の.crt0_headerの構造についてもここで定義されています。</p>
<a href="https://github.com/tock/libtock-c/blob/master/libtock/crt0.c" title="crt0.c" target="_blank" rel="noopener">crt0.c</a>

<p>アプリケーションはメモリ上のどこにおかれるかはビルド時には決定できません。さらにCortex-Mには仮想アドレス機構はないため、すべて物理アドレスで扱う必要があります。<br>そのため、<code>_start</code>関数では4つのメモリレイアウトに関する情報を受けとり、それをもとにアプリケーション上の情報を書き換えるということをやってます。<br>スタックやヒープ領域、デバッグ用の情報などを設定する他に、<a href="https://www.intel.co.jp/content/www/jp/ja/programmable/documentation/iga1420498949526.html#iga1409353027116" target="_blank" rel="noopener">グローバルオフセットテーブル(GOT)</a>の書き換えもやってます。<br>GOTの書き換えは<code>_start</code>で呼び出される<code>_c_start</code>で行われています。<br>159行目のループ中で最上位ビットで場合分けを行っていますが、<br>これはリンカスクリプトでROM領域は0x80000000以上の領域、RAM領域は0x00000000に配置されていることを利用して（17、18行目）、<br>本来アプリケーション領域にある定数を指すものなのか、スタック上に配置されるグローバル変数なのかを判別してアドレスを調整しているためです。</p>
<h2 id="システムコール"><a href="#システムコール" class="headerlink" title="システムコール"></a>システムコール</h2><p>カーネルとのやりとりは<code>SVC</code>命令を用いたシステムコールにより実現しています。<code>SVC</code>命令を介しているのでそこのインターフェースさえ何らかの方法で実装できれば、Rust以外の言語でもカーネルの機能を呼び出せるという仕組みです。<br>これは<code>libtock/tock.c</code>で実装されていて、サンプルアプリケーションでは直接は呼び出していませんが、<code>libtock-c</code>内の関数を呼び出すことにより間接的に使っています。<br>システムコールは5つのみです。簡単に説明すると</p>
<ul>
<li>yield: そのアプリケーションの終了をする。アプリケーションはスケジュールされなくなる</li>
<li>subscribe: ドライバのコールバック関数を登録する（例：タイマー割り込みで関数を呼び出してもらう）</li>
<li>command:　ドライバに対して指示を出す（例：LEDを点灯させる）</li>
<li>allow: カーネルとアプリケーション間で特定のメモリを共有させる（例：タイマードライバにコールバック制御用のデータ構造体を渡す）</li>
<li>memop: ヒープ領域を変更してもらったり、現在のメモリレイアウトの情報を手に入れるなど、メモリの操作を依頼する</li>
</ul>
<h2 id="おまけ"><a href="#おまけ" class="headerlink" title="おまけ"></a>おまけ</h2><p>サンプルアプリケーションで<code>tock_timer_t</code>の実体をユーザーアプリケーション側に持っていて、そのアドレスをカーネルに渡しています。<br>普通の場合はむしろ構造体の実体はカーネル側に持っておき、そのアドレスなりIDなりをユーザーアプリケーションが持つのが一般的だと思いますが、これには理由があります（以前のブログで紹介した論文にも書いてあります）。<br>今回は扱いませんでしたが、Tockでは複数のアプリケーションを動かすこともできます。<br>メモリ領域はアプリケーションごとに独立に持っていて、カーネルや他のアプリケーションとは基本的に共有しません。<br>もしカーネル側が実体を持っているとすると、あるユーザーアプリケーションが大量のタイマーを要求してきた場合、他のアプリケーションがメモリ不足によりタイマーを手に入れられない場合が考えられます。<br>アプリケーション側がタイマーの構造体を抱えれば、大量に要求してきたアプリケーションのみがメモリ不足になり、カーネル及び他のアプリケーションが困るということにはなりません。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/tock/tock/blob/master/doc/Userland.md" target="_blank" rel="noopener">tock/Userland</a></li>
<li><a href="https://github.com/tock/tock/blob/master/doc/Syscalls.md" target="_blank" rel="noopener">tock/Syscalls</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-01-07T15:00:00.000Z"><a href="/hexo/2019/01/08/expertise.html">2019-01-08</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2019/01/08/expertise.html">論文紹介： Towards a Theory of Software Development Expertise</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Twitterで見かけたどうやったらソフトウェア開発のプロになれるかの理論を構築したという論文。<br>ソフトウェアエンジニアにはもちろん、その上司だったり経営者とかにも参考になると思う</p>
<h2 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h2><ul>
<li>タイトル：Towards a Theory of Software Development Expertise</li>
<li>著者：Sebastian Baltes　(University of Trier) et al.</li>
<li>会議：Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE ’18)</li>
</ul>
<p>FSEというのはソフトウェア工学のトップカンファレンスの1つ。<br>どうすればソフトウェアエンジニアとして成長できるか、という話は本であったりブログであったりとそこらじゅうに溢れているが、このような論文となっているのはなかなかないのではなかろうか。<br>この論文で示されている著者らの構築したソフトウェアエンジニアのプロ（以下、原文に習いSDExp）になるための理論はもちろんのこと、その理論の構築過程もとてもおもしろい。<br>今回のブログでは理論の構築過程については自分の前提知識が足りなくまだ十分に理解できていないので、彼らの導いた理論の要旨、というよりも自分が印象に残った部分だけを紹介する。</p>
<p>元の論文はarXivで誰でも見られるので、詳しくはそちらへ<br><a href="https://arxiv.org/abs/1807.06087" target="_blank" rel="noopener">https://arxiv.org/abs/1807.06087</a></p>
<h2 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h2><p>彼らの理論はどのようなコンセプトがSDExpになるためには必要で、そのコンセプトがどのように関係しあっているか、というものをモデル化したものである。<br>この論文では３つのフェーズを経てそのモデルを構築している。</p>
<p>フェーズ１ではGithubとStack Overflowのアクティブなユーザーをサンプリングしてアンケートを取り、<br>その結果をベースに理論のベースとなるgrounded theory (GT)を構築している。<br>フェーズ２では既存の文献を用いて、GTに対してそれらの理論を埋め込んでいく形で発展させたモデルを構築する。<br>フェーズ３ではフェーズ２までの結果を踏まえて、フェーズ１よりも踏み込んだ形のアンケートをつくり、アクティブなJava開発者と長い開発経験を持つ開発者それぞれを対象として回答を得た。<br>Javaにターゲットを絞ったのは、対象をわかりやすくるため、研究開始時最もメジャーな言語であったJavaを選んだとのこと。<br>その結果を元に彼らの理論を完成させた。</p>
<h2 id="SDExpになるには"><a href="#SDExpになるには" class="headerlink" title="SDExpになるには"></a>SDExpになるには</h2><p>では、フェーズ３で構築した理論の図を論文から引用して見てみる</p>
<img src="/hexo/images/fse18figure4.png" title="figure 4">

<p>この巨大な図だけでは意味がわからないので、いくつか印象に残った部分だけを説明する。<br>このモデルはconcepts（コンセプト）とrelationship（関係）の２つからなる。<br>今回はコンセプトと関係の中からいくつか重要なものあるいは印象的だったものについて見ていく。</p>
<h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p>このモデルはTaskを中心に据えている。ここでいうTaskというのは要件定義であったりリファクタリングであったりするわけだが、それぞれのTaskには専用の知識であったり経験がある。<br>ソフトウェア開発には人が関わってくるので、人の関わり（Work Context）というのも重要な要素であるが、これもTask毎に違う。</p>
<p>フェーズ３にて最も重要だと思うTaskはという質問に対して、</p>
<ol>
<li>ソフトウェアアーキテクチャのデザイン</li>
<li>ソースコードを書く</li>
<li>要求を分析・理解する<br>が最も多い回答だった。</li>
</ol>
<h3 id="deliberate-practice"><a href="#deliberate-practice" class="headerlink" title="deliberate practice"></a>deliberate practice</h3><p>この論文でかなり強調されていた関係の１つにdeliberate practice（訳すとすれば計画的実践？）というのがある。<br>単に同じような経験をたくさん積む、というのはパフォーマンスを向上させるのには貢献しない、むしろ逆効果にすらなり得る。<br>経験の年数が能力に比例するのは最初の２年程度なので、その後はタスクの難易度を上げていくことでパフォーマンスをあげていくことが必要になる。これがdeliberate practiceである。<br>このdeliberate practiceにはパフォーマンスをモニターし、フィードバックを与えてあげるメンターなどの存在も必要になる。<br>また、自分の強みや弱みを把握する自己反省の資質も大事である。</p>
<h3 id="Work-Context-Task-Context"><a href="#Work-Context-Task-Context" class="headerlink" title="Work Context (Task Context)"></a>Work Context (Task Context)</h3><p>ソフトウェア開発にはマネージャーに相談したり、客からの要望に答えたりといったWork Contextが存在する。<br>フェーズ３で経営者が従業員の開発スキルを向上させるためにするべきことという質問に対する答えをカテゴライズすると</p>
<ol>
<li>学習を奨励する</li>
<li>実験することを奨励する</li>
<li>情報交換をしやすくする</li>
<li>自由を認める<br>というのが最も多い回答であった。<br>具体的には</li>
</ol>
<ul>
<li>外部のトレーニングコースの受講を勧める</li>
<li>カンファレンスの参加費を負担する</li>
<li>“Self-improvement Friday”、”lunch-and-learn session”などのミーティングやイベントで情報交換や学習の機会をつくる</li>
</ul>
<h3 id="Performance-Decline"><a href="#Performance-Decline" class="headerlink" title="Performance Decline"></a>Performance Decline</h3><p>年を経るごとにパフォーマンスが落ちていくということがあるが、これについても分析している。<br>フェーズ３での回答をカテゴライズすると</p>
<ol>
<li>モチベーションの低下</li>
<li>仕事の環境の変化</li>
<li>年齢による衰え</li>
<li>態度の変化</li>
<li>他のTaskへの移動<br>となった。<br>同じような仕事をやらされ続けてモチベーションを失う、きつい締切へのプレッシャー、マネージャーのコミュニケーション不足などなどが具体例として挙げられている。</li>
</ol>
<p>年齢による衰えについてはいくつかの実際の回答を引用している。例えば、「50代のころから新しい言語やフレームワークについていけなくなった」、「物忘れがひどくなってプログラムを書く速度が落ちた」、といったものであるが、<br>「40歳からritalinのような薬を飲むようにした。これは年老いたプログラマーの間では極めて一般的」などという回答まであった。<br>ritalinとは、どうやら多動性障害（ADHD）のための向精神剤らしいが（参考：<a href="https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%81%E3%83%AB%E3%83%95%E3%82%A7%E3%83%8B%E3%83%87%E3%83%BC%E3%83%88" target="_blank" rel="noopener">メチルフェニデール</a>）本当に広く使われていたりするのだろうか…</p>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>SDExpになるための理論を構築したという論文から、構築した理論についてその要素部分をかいつまんで紹介した。<br>紹介しきれなかったところ、また構築するまでの過程も非常におもしろかったので、興味があれば是非元論文を読んでもらいたい。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-30T13:05:52.000Z"><a href="/hexo/2018/12/30/this-year.html">2018-12-30</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2018/12/30/this-year.html">今年の振り返り</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今年は仕事以外でのインプット・アウトプットを増やすというのを1つ目標にして過ごしてきて、まだまだ少ないけれど去年よりは増えているのでいい傾向かなあと思っている</p>
<h2 id="RustでArmベアメタルプログラミング"><a href="#RustでArmベアメタルプログラミング" class="headerlink" title="RustでArmベアメタルプログラミング"></a>RustでArmベアメタルプログラミング</h2><p>以前から興味があったRustでArmベアメタルプログラミングができるようになってきたと聞いて、今年はいろいろな技術資料を漁りつつCortex-Mボードでのプログラミングを始めた。<br>現状だとUARTモジュールを動かしたり、タイマー割り込みを使ったり程度でまだまだなのだが、ゆくゆくは簡単なOSくらいにまでは進めていきたい。<br>とりあえず、目下の課題としてはSSD1306のOLEDモジュールを購入したので、それの動作用のライブラリ作成となりそう</p>
<h2 id="ブログ"><a href="#ブログ" class="headerlink" title="ブログ"></a>ブログ</h2><p>今年は技術関連であれば9件投稿した。本当は月一ペースで出したかったが、去年は2件しかなかったのでだいぶマシ。<br>とはいっても内容もまだまだなので、もうちょっとがんばりたい。<br>モチベーションをあげるためにGoogle Analysticも最近になってようやく導入した。<br>一応、ネタのストックはあるので、来年の早いうちに1件は出そうと思う。</p>
<h2 id="プログラミングコンテスト"><a href="#プログラミングコンテスト" class="headerlink" title="プログラミングコンテスト"></a>プログラミングコンテスト</h2><p>学生時代は頻繁に参加していたが、最近は参加する気が起きなくてスルーしていた。<br>しかし、なんだか簡単なプログラムを一気に書く瞬発力的なものが衰えてきた気がするので、Rustの勉強も兼ねてAtCoderのBeginner ContestのC問題を中心に時々解くようにした。<br>今後はちゃんとコンテストに参加してみようと思う。</p>
<h2 id="LFCE"><a href="#LFCE" class="headerlink" title="LFCE"></a>LFCE</h2><p>Linux Foundationの提供する<a href="https://training.linuxfoundation.org/certification/linux-foundation-certified-engineer-lfce/" target="_blank" rel="noopener">Linux Foundation Certified Engineer</a>(LFCE)の試験とそのためのオンラインレッスンを受講した。<br>結果は合格からは程遠かった。試験内容は口外できないのだが、レッスンに含まれていない内容もかなり出してきて、試験中は外部ネットアクセス禁止でmanしかアクセスできないというハードな内容だった。<br>一応、もう一回試験を受ける権利はあるのだが、そもそも合格してもメリットが少なそうだし、分野がそこまでしっかり勉強したい部分ではないので見送ると思う。<br>とはいっても、自分のLinuxシステムの理解の浅さや、すぐにとりあえずGoogle検索に頼ってしまう自分の姿勢は反省すべきだと思った。</p>
<h2 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h2><p><a href="https://turingcomplete.fm/" target="_blank" rel="noopener">TCFM</a>は低レイヤ関係の話を聞けるいい機会なのでモチベーション向上に役立った。<br>低レイヤプログラミングをがっつりやっているコミュニティに属していないので、情報交換の意味でもそういうコミュニティへの参加を増やせたらなあと思う</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/hexo/page/2/" class="alignleft prev">前の投稿</a>
  
  
    <a href="/hexo/page/4/" class="alignright next">次の投稿</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="検索">
    <input type="hidden" name="q" value="site:garasubo.github.io/hexo">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最近の投稿</h3>
  <ul class="entry">
    
      <li>
        <a href="/hexo/2022/09/16/isucon12.html">ISUCON12予選敗戦記</a>
      </li>
    
      <li>
        <a href="/hexo/2021/12/31/nenmatsu-poem.html">2021年の振り返り</a>
      </li>
    
      <li>
        <a href="/hexo/2021/11/07/rust-memory.html">Rustのメモリ管理機能とその特徴</a>
      </li>
    
      <li>
        <a href="/hexo/2021/08/26/isucon11.html">ISUCON11予選参加記（予選敗退）</a>
      </li>
    
      <li>
        <a href="/hexo/2021/04/04/theseus.html">論文紹介： Theseus: an Experiment in Operating System Structure and State Management</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
<a class="twitter-timeline" data-height="600" href="https://twitter.com/garasubo">Tweets by garasubo</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>



  

  
<div class="widget tag">
  <h3 class="title">タグ</h3>
  <ul class="entry">
  
    <li><a href="/hexo/tags/Arm/">Arm</a><small>2</small></li>
  
    <li><a href="/hexo/tags/CLI/">CLI</a><small>1</small></li>
  
    <li><a href="/hexo/tags/Cortex-M/">Cortex-M</a><small>2</small></li>
  
    <li><a href="/hexo/tags/Kernel-VM/">Kernel/VM</a><small>2</small></li>
  
    <li><a href="/hexo/tags/Rust/">Rust</a><small>16</small></li>
  
    <li><a href="/hexo/tags/embedded/">embedded</a><small>1</small></li>
  
    <li><a href="/hexo/tags/isucon/">isucon</a><small>6</small></li>
  
    <li><a href="/hexo/tags/osdev/">osdev</a><small>6</small></li>
  
    <li><a href="/hexo/tags/paper/">paper</a><small>10</small></li>
  
    <li><a href="/hexo/tags/procon/">procon</a><small>2</small></li>
  
    <li><a href="/hexo/tags/rust/">rust</a><small>1</small></li>
  
    <li><a href="/hexo/tags/unikernel/">unikernel</a><small>3</small></li>
  
    <li><a href="/hexo/tags/x11/">x11</a><small>1</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 garasubo
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/hexo/js/jquery.imagesloaded.min.js"></script>
<script src="/hexo/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'garasubo';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/hexo/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/hexo/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
