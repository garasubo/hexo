<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>己の不学を恥じる</title>
  <meta name="author" content="garasubo">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="己の不学を恥じる">

  
    <meta property="og:image" content="undefined">
  
  <meta property="og:type" content="website">
<meta property="og:title" content="己の不学を恥じる">
<meta property="og:url" content="http://garasubo.github.io/hexo/index.html">
<meta property="og:site_name" content="己の不学を恥じる">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="己の不学を恥じる">
<meta name="twitter:creator" content="@garasubo">

  <link href="/hexo/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="己の不学を恥じる" type="application/atom+xml">
  <link rel="stylesheet" href="/hexo/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/hexo/">己の不学を恥じる</a></h1>
  <h2><a href="/hexo/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/hexo/">Home</a></li>
    
      <li><a href="/hexo/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2022-09-15T15:00:00.000Z"><a href="/hexo/2022/09/16/isucon12.html">2022-09-16</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2022/09/16/isucon12.html">ISUCON12予選敗戦記</a></h1>
  

    </header>
    <div class="entry">
      
        <p>すでにずいぶんと時間が経ってしまったのですが、ISUCON12の予選に参加していました。結果は思わしくなく、予選敗退に終わってしまいました。<br>もう記憶がおぼろげになってしまっている部分もあるのですが、覚えている部分だけでも振り返って反省していきたいと思います。</p>
<a href="https://isucon.net/archives/56571716.html" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://parts.blog.livedoor.jp/img/usr/cmn/ogp_image/livedoor.png"></div><div class="descriptions"><div class="og-title">ISUCON12 まとめ : ISUCON公式Blog</div><div class="og-description">参加受付開始 ・6月1日(水) 10:00 第一期 ・6月6日(月) 20:00 第二期 ・6月11日(土) 10:00 第三期 ・7月 8日(金) 14:00 キャンセル枠分の追加募集  オンライン予選 ・7月23日(土) 10:00-18:00 　参加チーム数 698組（学生…</div></div></div></a>

<h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>今回はメンバーは2人でした。</p>
<p>事前練習用にはさくらインターネットさんのご厚意でさくらインターネットのクーポンが参加者に配布されて練習環境を整備することができたので、ありがたく使わせていただきました。<br>練習課題としては「達人が教えるWebパフォーマンスチューニング 〜ISUCONから学ぶ高速化の実践」の題材である<a href="https://github.com/catatsuy/private-isu" target="_blank" rel="noopener">private-isu</a>を用いました。<br>ただし、Rust実装は公式ではなかったので他の人が実装したものを使いました。</p>
<a href="https://github.com/Romira915/private-isu-rust" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://opengraph.githubassets.com/4a9a5d4bbea989419a321e877d16b0067bdb3b8593589a6d7567b64f690eaddc/Romira915/private-isu-rust"></div><div class="descriptions"><div class="og-title">GitHub - Romira915/private-isu-rust: Add Rust on private-isu</div><div class="og-description">Add Rust on private-isu. Contribute to Romira915/private-isu-rust development by creating an account on GitHub.</div></div></div></a>

<p>この練習会で、ansibleで最低限のbashrcや各種ツールをリモート環境にセットアップするものや、slackにalpでのログの結果を集計してアップロードするスクリプトなどを整備しました。</p>
<p>連絡はslackを用いることにしました。</p>
<h2 id="予選本番"><a href="#予選本番" class="headerlink" title="予選本番"></a>予選本番</h2><p>時刻は大体の時間です。</p>
<p>10:00 予選開始。ルール確認やコードをgithubに上げる作業などを行う。</p>
<p>10:33 Rustの初期実装でベンチを回す。Score: 2504</p>
<p>11:10 Docker上で動いていたアプリケーションを直接動くように変更。 Score: 2775</p>
<p>昔のDockerだとローカルホスト間のネットワーク通信のパフォーマンスが悪かったはずなのだが、解説でもそこは重要ではないとのことだったので、多分もう関係ない話だと思われる。<br>ただし、自分たちはRustのコンパイル済みのバイナリを手元からアップロードするデプロイ形式をとっていて、そのままのDockerスクリプトだとまずコンパイルが走ってしまうという仕組みになっていて非常にデプロイが遅くなってしまうため、外すという判断をした。<br>他のチームだとサーバーでコンパイルしてしまうとメモリ不足で困ったとかいう話も聞いたので、この判断は正解だったと思う。</p>
<p>11:31 DBアクセス時のロック周りが怪しいということで適当にはずしてみる変更をする。</p>
<p>何回か走らせて確かにパフォーマンスは上がるが、failedになるケースがあるのでむやみに外せないということになった。</p>
<p>ここで、ロックをファイルを用いる形式からRedisを使う形式に変更するという判断をして、自分が実装することになった。<br>しかし、Redisの習熟度が十分でなく、実装にかなり手こずってしまう。</p>
<p>11:42 もう1人のメンバーがMySQLの<code>id_generator</code>を使っていた箇所をuuidを用いてIDを生成する変更する。 Score: 4639</p>
<p>このへんでロックを適当に外したりとか自明にいらないクエリを削除したりなどを相方が試すがたいしてスコアは改善せず。</p>
<p>14:18 ロックを改善する実装がようやく出来上がる。 Score: 4376でたいして改善せず</p>
<p>このへんから自分は<code>visit_history</code>が<code>min(created_at)</code>なものしか引っ張ってきていないことを利用した最適化の実装にとりかかる。<br>相方はsqliteを使っている箇所をMySQLにしようとする。</p>
<p>15:43 MySQLを別サーバーに分離 Score: 4315</p>
<p>スコアこそ改善していないが、CPU使用率などのメトリックは改善していたので、将来的には有利なるはずと判断。</p>
<p>しかし、これ以降、やりたい改善の実装がうまく動かず、小手先の細かい改善をいくつか入れる程度で予選終了。なんの成果も得られませんでした。</p>
<h2 id="延長戦"><a href="#延長戦" class="headerlink" title="延長戦"></a>延長戦</h2><p>まず自分が担当していたvisit_historyの最適化ですが、DBのトランザクションを貼った時commitをし忘れるとかいうイージーミスでした。<br>書いていたときの気分としてはdropハンドラでやってくれるだろうと思っていたのですが、実際に呼ばれるのはrollbackです。冷静に考えればそのとおりですよね。</p>
<p>sqliteの移植作業の方はほぼほぼ完成していたものの、<code>player_score</code>テーブルが巨大でインスタンス起動時にすべてインサートできないという問題がありました。<br>しかし、<code>player_score</code>は<code>row_num</code>が最大のものしか利用されないという性質があるので、それを利用することでインサートする量を圧倒的に減らせます。<br>これには本番中には気がついていたのですが、実装が間に合いませんでした。</p>
<p>これらを直して<code>player_score</code>のCSV入稿による一括insertをbulk insertにしたり、transactionを取ることによって不要な自前ロックを外す、MySQL化できたのでN+1だった箇所を撲滅する、Redisでキャッシュするなどを実装することで最終的には5万点以上の点数をとることができました。</p>
<p>bulk insertをする場合、たまにMySQL側でデッドロックを起こすことに気が付きました。どうやらおなじテーブルへのbulk insertが複数スレッドで実行されると、トランザクションを貼っている状態でもindex更新のためのロックを取り合ってdead lockを起こすようです。<br>正直なんでMySQLがこれを正しくハンドルできないかはよくわからなかったのですが、Mutexを使いbulk insertできるのを1スレッドに限定することでなんとか回避しました。</p>
<h2 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h2><p>まず、素振りが足りていなかったのが大きかったかなと思います。<br>ライブラリを使い慣れていればtransactionがdropでrollbackされるなどでつまずくことはなかったし、<br>Redisでファイルロックを置き換える作業ももっとスムーズにできたはずです。</p>
<p>また、チームメイトを悪い意味で信頼しすぎていて、作業を任せっきりにしてしまったのもよくなかったです。<br>コンテスト中はどうしても焦りが出てしまったり、そもそも知識が足りていない分野だと気づきが共有できていなかったりします。<br>ロックについて相方とじっくり挙動を調べたりすれば、Redis置き換えなどという無駄なステップを踏まずにすんだかもしれないし、<br>SQLite移行ももう少しすんなりいったかもしれません。<br>ペアプロや一緒に考える時間はもう少し積極的にとって良いと思いました。</p>
<p>RustのWebアプリケーションでのプロファイリング手法についてもちゃんと検討したいなと思いました。<br>MySQLやnginxのログ解析は<code>pt-query-digest</code>や<code>mysqldumpslow</code>や<code>alp</code>などで確立されていますが、各関数でどれくらいの処理がかかっているかのデータを知りたい場面はそこそこにあります。<br>他の予選通過チームは自前のmacroを用意してOpenTelemetryでプロファイリングをとっているようだった。</p>
<a href="https://zenn.dev/daiju/articles/165da7a5589434" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://res.cloudinary.com/zenn/image/upload/s--92for2m7--/co_rgb:222%2Cg_south_west%2Cl_text:notosansjp-medium.otf_37_bold:%25E5%25A4%25A7%25E6%25A8%25B9%2Cx_203%2Cy_98/c_fit%2Cco_rgb:222%2Cg_north_west%2Cl_text:notosansjp-medium.otf_70_bold:ISUCON12%25E4%25BA%2588%25E9%2581%25B8%25E5%258F%2582%25E5%258A%25A0%25E8%25A8%2598%2520Rust%25E3%2581%25A7%25E4%25BA%2588%25E9%2581%25B8%25E7%25AA%2581%25E7%25A0%25B4%25E3%2581%2597%25E3%2581%259F%2Cw_1010%2Cx_90%2Cy_100/g_south_west%2Ch_90%2Cl_fetch:aHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vemVubi9pbWFnZS9mZXRjaC9zLS1OMEZMdUJpUy0tL2NfbGltaXQlMkNmX2F1dG8lMkNmbF9wcm9ncmVzc2l2ZSUyQ3FfYXV0byUyQ3dfNzAvaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3plbm4tdXNlci11cGxvYWQvYXZhdGFyL2M0OTkyOGRlYjMuanBlZw==%2Cr_max%2Cw_90%2Cx_87%2Cy_72/v1627274783/default/og-base_z4sxah.png"></div><div class="descriptions"><div class="og-title">ISUCON12予選参加記 Rustで予選突破した</div></div></div></a>

<p>著名なライブラリである<code>tracing</code>でもSQLの文字列とかはキャプチャできないが、最低限関数呼び出しのトレースは取れるはずなので次回は活用したい。</p>
<p>他チームで参考になりそうな戦略としてはSQL文を一旦すべてスプレッドシートに洗い出すという戦略はよさそうと思いました。</p>
<a href="https://diary.hatenablog.jp/" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png"></div><div class="descriptions"><div class="og-title">Write and Run</div><div class="og-description">it&#39;s a simple way, but the only way.</div></div></div></a>

<p>狙いとしてはアクセスパターンを一覧にすることで、不要なDB操作を洗い出したり、今回の場合はSQLite移行の難易度を見積もったりとslow query分析だけでは見えてこないものを発見しやすくするというもので、これはシンプルながら強力そうな戦略に感じました。<br>やはり冷静になってアプリを分析する時間は必要。</p>
<p>来年はちゃんと3人メンバーを集めて予選通過を狙いたいです。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-12-30T15:00:00.000Z"><a href="/hexo/2021/12/31/nenmatsu-poem.html">2021-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2021/12/31/nenmatsu-poem.html">2021年の振り返り</a></h1>
  

    </header>
    <div class="entry">
      
        <p>年末恒例、今年の自分の振り返りをやっていく。<br>普段は避けているやや政治的な意見にも踏み込むので苦手な方はブラウザバックを推奨。<br>またお約束ではあるが、個人の見解であり、所属する団体を代表するものではない。</p>
<h2 id="今年の成果"><a href="#今年の成果" class="headerlink" title="今年の成果"></a>今年の成果</h2><p>自作OSに関する成果については以前の記事にまとめた</p>
<a href="https://zenn.dev/garasubo/articles/dcfc888668a739" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://res.cloudinary.com/zenn/image/upload/s--6Ga8CRIj--/co_rgb:222%2Cg_south_west%2Cl_text:notosansjp-medium.otf_37_bold:%25E3%2582%25AC%25E3%2583%25A9%25E3%2582%25B9%25E3%2583%259C%25E3%2583%25BC%2Cx_203%2Cy_98/c_fit%2Cco_rgb:222%2Cg_north_west%2Cl_text:notosansjp-medium.otf_70_bold:Rust%25E3%2581%25A7%25E3%2581%25AE%25E4%25BD%258E%25E3%2583%25AC%25E3%2582%25A4%25E3%2583%25A4%25E3%2583%25BC%25E3%2583%2597%25E3%2583%25AD%25E3%2582%25B0%25E3%2583%25A9%25E3%2583%259F%25E3%2583%25B3%25E3%2582%25B0%25202021%2Cw_1010%2Cx_90%2Cy_100/g_south_west%2Ch_90%2Cl_fetch:aHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vemVubi9pbWFnZS9mZXRjaC9zLS04ZWZiNGN4ci0tL2NfbGltaXQlMkNmX2F1dG8lMkNmbF9wcm9ncmVzc2l2ZSUyQ3FfYXV0byUyQ3dfNzAvaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3plbm4tdXNlci11cGxvYWQvYXZhdGFyLzFiYWY4YTQ4NjEuanBlZw==%2Cr_max%2Cw_90%2Cx_87%2Cy_72/v1627274783/default/og-base_z4sxah.png"></div><div class="descriptions"><div class="og-title">Rustでの低レイヤープログラミング 2021</div></div></div></a>

<h3 id="ブログ記事などのアウトプット"><a href="#ブログ記事などのアウトプット" class="headerlink" title="ブログ記事などのアウトプット"></a>ブログ記事などのアウトプット</h3><p>今年はこのブログにこの記事を除いて4本、<a href="https://zenn.dev/garasubo" target="_blank" rel="noopener">Zenn</a>のほうに3本の記事を投稿した。<br>これは去年よりも少ないことになるのだが、代わりに技術書展において去年執筆した自作OSドキュメントを改訂して同人誌として販売した</p>
<a href="https://techbookfest.org/product/6484983722016768?productVariantID=4877729004519424" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://techbookfest.org/api/product/ogp/image/6484983722016768"></div><div class="descriptions"><div class="og-title">Rustで始める自作組込みOS入門：己の不学を恥じる</div><div class="og-description">組込みデバイス向けのOSをRustでつくってみませんか？
Wio Terminalを題材にOS自作への第一歩を解説します。
</div></div></div></a>

<p>また、<a href="https://gihyo.jp/magazine/SD/archive/2021/202109" target="_blank" rel="noopener">技術評論社刊「ソフトウェアデザイン 2021年9月号」</a>にて、Rustのメモリ管理についての記事を寄稿した。<br>こちらの記事は一部改訂して<a href="/hexo/2021/11/07/rust-memory.html">前回のブログ記事</a>とした。</p>
<p>その他、<a href="https://kernelvm.connpass.com/event/201059/" target="_blank" rel="noopener">Kernel/VM探検隊</a>などのオンラインLT会での発表もいくつか行った。</p>
<p>と、総合すれば去年と同じくらいアウトプットを達成したのではなかろうか。<br>ありがたいことにTwitterでのフォロワー数も900人代まで増えているので、自分の発信している情報が有益だと思ってくださっている方が増えてきている（と信じたい）。</p>
<p>また、これは他の場所では何回か言っているが、自作OS本を商業誌として出すように現在ブラッシュアップ中である。やや作業停滞気味なので年明けからは本気出す。</p>
<h3 id="Rust雑談会（仮）"><a href="#Rust雑談会（仮）" class="headerlink" title="Rust雑談会（仮）"></a>Rust雑談会（仮）</h3><p>Twitter Spacesを主に利用してRust雑談会という企画を<a href="https://twitter.com/dorayaki_kun" target="_blank" rel="noopener">dorayakiさん</a>と一緒にやり始めた。<br>Rustに関する話題をゆるく雑談するというポッドキャストもどきのような企画で、大体視聴者は10人前後いる程度には反響がある。<br>内容についてはまだまだ手探り状態で、大きなテーマを用意してそれにそって話すこともあれば、小さい最近の話題を細かく話すこともある。<br>アーカイブもYouTubeに上げているので興味のある方はどうぞ</p>


<p>正直、どういうスタイルの方が需要があるのかよくわかっていないので、フィードバックをもらえると助かります。<br>あと、アーカイブを聞き返すと自分のトークスキルがまだまだだなあと痛感させられてつらい</p>
<h3 id="来年以降の方針"><a href="#来年以降の方針" class="headerlink" title="来年以降の方針"></a>来年以降の方針</h3><p>アウトプットの機会は保てたと思うが、まだまだ質・量を増やしたいと思っている。<br>また、アウトプットの方向性もちょっと変えていきたいと思っている。<br>今までは内容重視でどう発信するのかについてはあまり真剣にやってこなかった。<br>が、これからはもうちょっと注目されやすい方法にも手を出してみようと思っている。<br>具体的には、技術ブログをこちらのブログで主に出していたが、これからはZennのほうに移していこうと思っている。<br>ZennはGithub連携により手元に記事のソースを残しつつホストできるので運営の一存で記事が抹消されたりといったリスクも少なく、いざというとき他のプラットフォームに移行しやすい。<br>自前のブログでホストし続けるよりかは、Zennというプラットフォームにのっかるほうがアクセスされやすくなるので、こちらに移行していく。</p>
<p>Rust雑談会のようなTwitter Spaces等を利用したライブコンテンツも積極的に取り組みたい。<br>Twitterで単発で情報を発信するよりかは、誰かとしゃべりながらやったほうがいろいろと知見を深めやすいし、アクセスする側も手軽でいいといいと思っている。</p>
<p>こういう情報発信にもっと力を入れたいというのはいくつか理由がある。1つは単に自分が楽しいから。<br>もう1つは自分の能力をきちんと示すためである。残念ながら僕はコンテストの受賞歴のようなかっこいい経歴はない。<br>とりあえず今の会社には評価してもらって働けているが、他の会社・組織ではどうだろうか。社内での成果はアピールしづらく、さらに自分は自己アピールが苦手である。<br>こう考えると、目に見える形で何かしらの成果を残しておかないと、評価を得るのは難しい。もちろん、きちんと能力を身に着けるのも大事ではあるが、世の中誰もが純粋に能力を見抜いて評価してくれるほど甘くない。<br>若手という肩書もそろそろ厳しくなってくる中、アウトプットの質・量だけでなく方法も変えて、評価を得ることに欲を出し始めても良いころでは、という考えがある。<br>もう1つは情報科学全体への貢献という観点である。自分はプライベートでも仕事でもOSSなどの広く開かれたリソースに助けられながら情報科学を身に着けてきた。<br>そういう開かれたリソースへの恩返しとして、自分も開かれたリソースというものを可能な限り出して情報科学への敷居を下げていきたいという思いがあったりする。</p>
<p>Github Sponsorsもやっているので、もし活動に賛同していただける方がいらしたら支援をお願いします。</p>
<a href="https://github.com/sponsors/garasubo" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://avatars.githubusercontent.com/u/2667091?s=400&v=4"></div><div class="descriptions"><div class="og-title">Sponsor @garasubo on GitHub Sponsors</div><div class="og-description">Support garasubo’s open source work</div></div></div></a>

<h3 id="コンテスト"><a href="#コンテスト" class="headerlink" title="コンテスト"></a>コンテスト</h3><p>ISUCON、ICFPC、SECCONに参加した。ISUCONは予選敗退、ICFPCは去年よりは順位のいい11位、SECCONは久々の参加でありwarm up問題すら苦戦してふるわなかった。</p>
<p>AtCoder系の競技プログラミングは過去問を週に1，2本解く程度になってしまった。水diff程度は解けるが青diffになるとかなり解くのがつらくなってしまう。<br>最近、コーディングの瞬発力の衰えを感じているので、定期的に解いて行きたい。</p>
<h3 id="自作PC"><a href="#自作PC" class="headerlink" title="自作PC"></a>自作PC</h3><p>実は今まで性能の微妙なIntel NUCをメインの開発機としてプライベートでは開発していた。<br>最近、ファンの音がうるさくなってきたり、ディスクの空き容量がカツカツになったりと怪しくなってきたので思い切って今まで手を出してこなかった自作PCに手を出してみた。</p>
<p>初めての自作PCでノウハウが全くなかったので秋葉原のTSUKUMOに行き、店員さんの言われるがままにパーツを購入し組み立てた。<br>Ryzen 7+Geforce RTX 2060+メモリ32GB+PCIe 4.0 SSD 1TBでおおよそ20万円ほど。Linuxのビルドとかも視野に入れてSSDの入出力速度は重視し、コアもそこそこ強めのを選んだ。<br>GPUはNVIDIA Broadcastに興味があったのでそれが動く最低限のものを選んだ。</p>
<p>Windows+Ubuntuのデュアルブートにして、ある程度運用できているがトラブルもいくつかある。まず、Ubuntu側特有の問題として、動画や音声を再生するときノイズが入ったり音がズレたりする。<br>Pulse Audioを再起動すれば治ることが多いのだが、対処方法がよくわかっていなくてそこそこ困る。</p>
<p>致命的なのはSSDがすでに2回も謎の故障をしていることである。一回目は突然SSDとして認識されなくなり、初期不良として交換品をもらったのだが、交換品も全く同じように壊れてしまった。<br>一応、故障前に起動時に中に入っているOSを読み取れず起動失敗になる現象がたまに起きるという前兆があるにはあったが、2回ともそこから突然機能停止になってしまった。<br>店員さんにも相談したのだが、別に使っているSSDの型番やマザーボードでの故障報告が頻発しているというわけではなく、原因が未だに不明のままである。<br>交換品の到着にしばらく時間がかかるとのことだったので、別のメーカーのSSDを新たに購入し現在運用中で今のところ故障する気配はないが果たして…</p>
<p>自作PCはやはりトラブルが発生することは多く、コストパフォーマンスでいっても特別安くなったわけではない。<br>とはいっても、部品を選んでカスタマイズして組み立てるのは僕は楽しいと思うので、そういうのが好きな人にはおススメではある。</p>
<h2 id="考えたこととか"><a href="#考えたこととか" class="headerlink" title="考えたこととか"></a>考えたこととか</h2><h3 id="競技プログラミング"><a href="#競技プログラミング" class="headerlink" title="競技プログラミング"></a>競技プログラミング</h3><p>今年の4月ごろ、競技プログラミングに関する批判の記事があり、これに関して議論が盛り上がった。</p>
<a href="https://nuc.hatenadiary.org/entry/2021/03/31" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://ogimage.blog.st-hatena.com/17680117127074159362/26006613710476988/1617232013"></div><div class="descriptions"><div class="og-title">Twitter で医師を拾ってきて Google のソフトウェアエンジニアにするだけの簡単なお仕事 - 白のカピバラの逆極限 S.144-3</div><div class="og-description">はじめに 「【転職エントリ】Googleに入社します｜Lillian｜note」という、医師から未経験で Google のソフトウェアエンジニアになった記事があります。 note.com 私は、この記事に出てくる「とある元 Google のソフトウェアエンジニア」で、面接の対策を…</div></div></div></a>

<p>これに対して自分の知り合いの知り合いくらいの観測範囲でものすごくこの記事をほめたたえている人も少なくなかった。<br>しかし、自分は当時Twitterでも軽く言及した通り全く賛同できず、なぜここまで持ち上げられるのか理解に苦しんだ。</p>
<p>この記事は要するに競技プログラミングではコンピューター科学の一部分しか学ぶことができなくて、Googleなどのトップ企業に入る能力を身に着けるには悪影響すらありえるということを主張している。<br>競技プログラミングが万能でない点については同意するが、このような議論は僕の周りの競技プログラミングをやっている人からすると「月刊競技プログラミングは役に立たない」と揶揄されるくらい度々指摘されてきた話で、<br>なぜ今更になってここまで盛り上がるのかが理解できない話であった。</p>
<p>確かに、最近はAtCoder社を中心に競技プログラミングを利用した採用だったりエンジニア教育が注目されている。そのため、競技プログラミングがこんなにも役に立った、という話題がクローズアップされやすくなってきたのかなと感じる。<br>が、僕らが就職活動などを控えていた2010年代前半くらいの空気感だと、そもそも競技プログラミングの知名度が低く、レッドコーダーと言われてもピンとこない、採用でも特に有利にならないということが珍しくなかった。<br>そのため、僕の周りのレッドコーダークラスの人間も自分の能力は業務で役に立つのだろうかと疑問を持つ人間の方が多いように感じた。<br>そういう疑念の反証として、こうした競技プログラミングは役に立つ、といった話が持ち上げられたという空気を僕は感じていた。</p>
<p>ただ、それは僕の観測範囲内だけの話であった可能性はある。<br>実際、AtCoder社の社長であるchokudai氏が、かなり競技プログラミングを持ち上げるような発言を連発しているイメージがあり、そういう発言に感化されて競技プログラミングに対する幻想を抱く人間が一定数いた可能性はあり、<br>記事の著者がそういう人たちを観測してああいう記事を書いた可能性はある。が、記事を書くきっかけになった人物として名指しされている<a href="https://twitter.com/drken1215" target="_blank" rel="noopener">@drken1215</a>さんは僕も競技プログラミング関連で何度か名前を見た人だし、多分僕と同じような空気を感じていた人ではないだろうか…</p>
<p>議論が古いというのは観測範囲の違いとかでしかたなかったとしても、現在の競技プログラミングのあり方についての記述もかなり疑問な部分が多い。<br>しかも、そういう思い込みに基づいて「ホラー」だとか「カーゴ・カルト」などという形容をしているのはいかがなものであろうか。</p>
<p>これに対して、恐らく批判の矛先になっていたであろうAtCoder社の社長のchokudai氏が反論記事を書いている。<br>chokudai氏自身も競技プログラミングの限界など承知であり、そのうえで競技プログラミングにどういう価値があるかという考えをまとめているという記事になっている。<br>やや反論としてはズレているのではと思う箇所もあるのだが、競技プログラミングの意義・限界については納得できる内容になっていると思う。</p>
<a href="https://chokudai.hatenablog.com/entry/2021/04/01/115755" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://ogimage.blog.st-hatena.com/12921228815718296360/26006613710985562/1617255062"></div><div class="descriptions"><div class="og-title">競技プログラミングの在り方　～「競技プログラミングを我々が終わらせる」を受けて～ - chokudaiのブログ</div><div class="og-description">nuc.hatenadiary.org 競技プログラミングについての言及があったのですが、バズってる＋競技プログラミングについて、納得がいかない記述がかなり多く見受けられたので、反論記事を書きました。</div></div></div></a>

<p>個人的には競技プログラミングをきっかけにコンピューター科学に興味を持ち始めて、情報科学を大学で学び、Googleやそれに並ぶような企業で働く知人を何人も観測しているので、競技プログラミングという文化そのものは非常に有意義なものであると思っている。<br>競技プログラミングは確かにコンピューター科学の一部分でしかないものの、その一分野の敷居を下げたAtCoderの取り組みは素晴らしいものだと思っているし、現に自分もトレーニングとしてAtCoderで出題された問題を解くことがある。<br>確かに競技プログラミングをやりこんだ人たちは知識が偏っていたり独特の思考に染まっていて驚くことは少なくはないのだが、それは単に入口が違うからでしかたないことだと思うし、「終わらせる」などという強い言葉でコミュニティを否定するのは違うでしょう。</p>
<p>正直、あの記事はchokudai氏やその周辺コミュニティへの個人的な嫉妬・嫌悪感にそれっぽい理由をつけただけのものではないだろうかとすら感じた（本人は別の記事で否定しているが、矛盾だらけの弁明に感じた）。<br>絶賛している人も競技プログラミングからは遠い人がメインだったし、そういうネガティブな感情から来るものという側面もあったのではなかろうか。</p>
<h3 id="プログラマになるまでのルート"><a href="#プログラマになるまでのルート" class="headerlink" title="プログラマになるまでのルート"></a>プログラマになるまでのルート</h3><p>あの記事は主に競技プログラミングを中心にプログラマ、それもGoogleクラスのトップ企業で通用する、になるにはというものを論じていたが、それ以外にもプログラマに必要な能力は何か・どうやったら身につくのかという話題は定期的にTwitterで観測した。</p>
<p>自分は具体的な社名は伏せるが、一応それなりの規模をもつサービスを展開する外資系のウェブ企業に所属してウェブサービスの開発を本業としている。主にフロントエンド寄りの仕事が多い。<br>大学では情報科学科に入りコンピューター科学の基礎は一通り学び、競技プログラミングも嗜む程度には取り組んだ。<br>そこで感じるのは、必ずしも競技プログラミングのような高度なアルゴリズムを構築するような能力が必要とされる場面は限らていて、さらに言えばコンピューター科学の知識が直接役に立つ場面というのもあんまりない。<br>フロントエンド開発はユーザーのアクションに対してAPIリクエストをバックエンドに投げ、そのJSONのレスポンスに対応してUIをデザイナーの指示通りに表示させるようなロジックを組むのが主な仕事になる。<br>これを「JSONに色を付ける作業」とかジョークで言われたりするように、そこに数学的な知識とか高度なコンピューター科学の知識はそこまで役に立たない。<br>バックエンドのほうも、フロントエンド開発に近い領域だとデータベースや他のマイクロサービスなどからの応答をいい感じにJSONに加工して返すだけの場面が多く、こちらは「gRPCの詰め替え作業」とかジョークで言われたりする。こちらもコンピューター科学の知識は直接は役に立たない。<br>問題となるのは、これらの実装をいかに効率的に実現するかであるが、計算量的な効率化ではなく、機能の拡張性であったり設計の見通しの良さといった効率性がポイントとなる。<br>こういうところで必要になるのは、プログラミング言語やそのドメインに特化したライブラリやツールの使い方のような知識だったり、設計のベストプラクティスのようなものがメインになる。<br>こういうものは実際に業務での開発経験や、そのドメインの最新情報をブログや勉強会などでキャッチアップすることが多い。コンピューター科学の基礎的な勉強とはかなり距離がある。</p>
<p>じゃあ、競技プログラミングやコンピューター科学の勉強は無意味であったかというとそうではない。機会は少ないといったが、変なところ（ライブラリ内のバグ・インフラの故障）でトラブルが起きた場合に役に立つのはコンピューター科学の知識だったりする。<br>また、ドメイン知識の習得を下支えするのは基礎能力やコンピューター科学の知識であるとは感じる。<br>競技プログラミングが一定以上できる人間は、一度知識さえ身に着ければそこそこのスピードでこれらの業務をこなしてくれる。<br>こういうのを考えると、ある程度のプログラマであれば必ずしもコンピューター科学の知識を身に着ける必要はないかもしれないが、Googleなどのトップクラスを狙うのであれば無関心でいるというのは厳しいのではないか、と考えている。</p>
<p>他にも数学能力の必要性も議論されたりする。確かに自分のウェブフロントエンドの領域に限って言えば直接役に立たない場面が多い。<br>が、やはり下支えしているのは数学的な能力ではないのかなあと思っている。<br>前述の記事では東大理Ⅲ出身の医者をGoogleに入れたとあったが、東大理Ⅲ出身ともなればかなり数学の訓練は積んでいるはずである。<br>また、知り合いでGoogleなどの企業に入るなど高いプログラミング能力の人たちは、プログラミングを始めたのは大学からという人も結構いる。<br>昨今、年齢の若い内のプログラミング教育がよく話題になるが、個人的には本人のある領域があればどんどんプログラミングの世界に踏み入れるのは大賛成であるが、<br>焦ってプログラミングを始めてドメイン知識の習得に努めなくてもいいのではないかなあと思うし、数学教育のような基礎の重要性は変わらないと思う。<br>また、もともと数学（高校レベルあたりを想定）が苦手でさっぱりという人間が社会人になってからプログラミングで頭角を表す、みたいなのは厳しいのではないかなあとか思う。</p>
<p>数学力やコンピューター科学の知識は下支えになるとは言ったが、やっぱり最後は実践経験を積んで強くなるしかないとは思う。<br>その実践経験を積む方法として、会社に入る以外の方法だと、競技プログラミングは一つの選択肢になるとは思う。<br>AtCoder系のショートコンテストだと書くコードは非常に短く、問われるのはアルゴリズム寄りの知識がメインとなり偏ってしまうが、他にもプログラミングコンテストはいくつもある。<br>ISUCONだとウェブ系のドメイン知識が必要になり、競技時間も長くデバッグ能力・問題分析能力なども実践を通して問われる。<br>ICFPCの場合、多くのチームが問題専用の各種ツールを用意することが多く、そういうツールの開発を通じて得るものも多いだろう。<br>SECCONなどのCTFではセキュリティや低レイヤーの知識を問われることが多く、それらを手を動かして試す絶好の機会になるだろう。<br>その他、最近は自作OSや自作CPUなどの自作〇〇が流行っている（気がする）。これらの書籍・ドキュメントを入門として実際に自作〇〇をすると、今まで本で読んだだけの部分の理解がグンと深まる。<br>自分の例で言うと、自作ハイパーバイザをつくったときにメモリ管理ユニットの仕様書を読みながらコードを書いたのだかが、ページングのCPUの提供している機能を生で触ることができて、授業で習ったこととリンクして非常によい経験になった。<br>OSSへの貢献、ウェブサービスを自分で開発してみるなど他にも実践の機会はそこら中にあり、無料でアクセスできるリソースも多い。<br>僕はコンピューター科学は実践してなんぼ、と信じているのでやはり手を動かすというのはなんだかんだ大事だと思うし、その過程でコンピューター科学への理解も大事にしてほしいなと思う。</p>
<h3 id="コインハイブ裁判"><a href="#コインハイブ裁判" class="headerlink" title="コインハイブ裁判"></a>コインハイブ裁判</h3><p>地裁で無罪判決が出てから高裁で逆転有罪となっていた所謂コインハイブ裁判が最高裁での審理が始まった</p>
<a href="https://www3.nhk.or.jp/news/html/20211209/k10013382211000.html" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://www3.nhk.or.jp/news/html/20211209/K10013382211_2112091812_2112091915_01_02.jpg"></div><div class="descriptions"><div class="og-title">PC無断利用し暗号資産獲得 最高裁で有罪判決見直しの可能性も | NHKニュース</div><div class="og-description">【NHK】サイトを閲覧した人のパソコンを無断で利用していわゆる仮想通貨＝暗号資産を獲得するプログラムが違法かどうかが争われ、1審は…</div></div></div></a>

<p>以前も何回か主張してはいるが、このコインハイブ利用による検挙と高裁での有罪判決にはかなり疑問を持っている。<br>とはいうものの、自分は法律関係の知識は高校とかでの一般知識程度に留まっていて、法律の観点からどこが問題かを正しく解釈できているかに100%の自信はない。<br>また、コインハイブ裁判に関わらず、この手のプログラマを標的（？）とした検挙というのはよく話題になったり、またプログラミングに関わらないが日常のひょっとしたことから警察のお世話になってしまう話なども流れてくる。</p>
<p>そういったトラブルへの備えと、そのような法律に関する知識をもとに自分の考えをまとめたいという思いから、最近法律系の本を読んだりしている。</p>
<p>現在読み進めているのは「法解釈講義」という法学部生の教科書としても使われている本だ。内容が濃く理解するのはやや大変だが、これといった専門知識もなく読むことができおもしろい</p>
<a href="http://www.utp.or.jp/book/b325418.html" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img></div><div class="descriptions"><div class="og-title">法解釈講義（POD版） - 東京大学出版会 </div></div></div></a>

<p>また、「Wizard Bible事件から考えるサイバーセキュリティ」のほうも購入した。<br>こちらは近年の疑問視されたセキュリティ関連の裁判の総まとめとなっていて、とてもおもしろいのだが、警察・検察の理不尽な取り調べの部分は読んでいて不快感が強い。将来警察・検察とは縁がないことを願いたい。</p>
<a href="https://peaks.cc/books/wizard_bible_security" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://peaks-img.s3-ap-northeast-1.amazonaws.com/wizard_bible_security_twittercard.png"></div><div class="descriptions"><div class="og-title">Wizard Bible事件から考えるサイバーセキュリティ - PEAKS</div><div class="og-description"> 本書はサイバー犯罪関連法の問題点について警鐘を鳴らすことを目的としています。
  
国民をサイバー犯罪から守るための法律が、近年になってサイバー犯罪とは必ずしも言い難い事例に適用されて大きな問題となりました。これにより、日本のセキュリティ研究が萎縮する事態に陥っています。本書で…</div></div></div></a>

<p>法律と技術の関係はたびたび問題になるにも関わらず、なかなか改善の兆しはない。司法側の問題もいろいろあると思うが、近年だとウェブ開発側の倫理を問われることも多く、欧米では各種規制が進んでいるが日本ではなかなか進んでいない。<br>自分もウェブ開発でお金を稼ぐ身としてはきちんと自分の意見を持って、邪悪な開発に手を染めないようにはしたい。</p>
<h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>新型コロナの流行以来制限の多い生活が続き、今年もなかなかに息苦しい一年であった。<br>確かにワクチン接種が進み、流行も一時期落ち着いたりして制限がゆるくなってきた分野もあった。<br>自分は商業誌への寄稿といった新しいチャンスを得ることもあり、恵まれているほうなのであろう。<br>とはいっても、つらいものはつらく、在宅勤務でのパフォーマンス低下は以前はそこまででもなかったが最近はかなり集中するのが難しくなってきたように感じられる。<br>YouTubeやらTwitterやらをなんとなく眺めて時間をだらだらと過ごすことも多くなってきてしまった。<br>生活リズムもかなり乱れ始めていたりして、これらはなんとか改善したい。</p>
<p>年齢的にも若手を名乗るのには厳しくなってきているので、もっと貪欲に新しいことに手を出したり成果を形にすることに注力したいと思う。</p>
<p>と、雑にいろんなことを書き殴ったが、来年もいろいろとやっていきたいので、何卒宜しくお願い致します。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-11-06T15:00:00.000Z"><a href="/hexo/2021/11/07/rust-memory.html">2021-11-07</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2021/11/07/rust-memory.html">Rustのメモリ管理機能とその特徴</a></h1>
  

    </header>
    <div class="entry">
      
        <p>初出：<a href="https://gihyo.jp/magazine/SD/archive/2021/202109" target="_blank" rel="noopener">技術評論社刊「ソフトウェアデザイン 2021年9月号」</a></p>
<p>先日、技術評論社よりRustのメモリ管理機能についての特集に寄稿させて頂きました。<br>この記事は自分が寄稿させていただいた記事をブログ用に一部推敲・加筆を加えたものです。<br>なお、ソフトウェアデザインでの特集ではより実践的な例でのメモリ管理についての解説もあるので、興味のある方は本誌のほうも手にとっていただければと思います。</p>
<h2 id="プログラム言語におけるメモリ管理の課題"><a href="#プログラム言語におけるメモリ管理の課題" class="headerlink" title="プログラム言語におけるメモリ管理の課題"></a>プログラム言語におけるメモリ管理の課題</h2><p>プログラミングにおける課題の一つとしてどうやってメモリ領域（ヒープ領域）を管理するかというものがあります。</p>
<p>C言語では<code>malloc</code>/<code>free</code>関数などを用いて手動でメモリを管理しています。<br>これらの関数はメモリアドレスを示すポインタを介してメモリ管理を行います。<br><code>malloc</code>関数は必要なメモリ領域を確保してその先頭番地のポインタを返し、プログラム内ではその番地のメモリを読み書きし、使い終わったら<code>free</code>関数にその番地を教えて解放する、という流れです。<br>この方式では、どのタイミングでメモリが操作されるかが明確なので実行時間やメモリ効率がいいのですが、人の手で毎回操作しないといけないので、プログラミングに複雑になりやすくミスを起こしやすいことが知られています。<br>例えば、ポインタの指し示す先のメモリがもう解放されていたり、他の用途で使われているのにもかかわらず値を読み書きしてしまうことがあります。<br>C++ではもう少し抽象化された形を用いていますが、基本的には自分で必要なタイミングでメモリの確保・解放を行う必要があり同様の課題を抱えています。</p>
<p>一方、Python・Rubyなどのスクリプト言語を中心に用いられているのがガベージコレクション（GC）という仕組みです。<br>この方式では実行環境が適当なタイミングで現在使用中のメモリの内容をチェックして、もう必要のないメモリを自動で開放するというものです。<br>この方式では、プログラマがメモリ解放のタイミングを指定する必要がなく、メモリ解放に関わるミスを防ぐことができます。<br>その一方で、GCを実行する際にプログラムを一時的に止める必要があったり、GCを走らせるまでは必要のないメモリを確保し続けたままになってしまうなど、実行時の効率が問題になるケースがあります。</p>
<p>Rustは所有権とライフタイムを利用することで、GCのような実行時のメモリ管理コストをなくし、かつ手動でのメモリ管理で起きがちなバグをコンパイラレベルで検知することができます。<br>この所有権とライフタイムがRustを学ぶ上での大きな壁の一つで完全に使いこなすのはかなり大変です。<br>かくいう筆者も、数年間Rustを書いていますが頻繁に頭を悩ませる問題であり、コンパイラに怒られながらなんとか直すということしながら書いています。<br>しかしながら、使いこなすことで安全性が高くかつ実行時コストが非常に少ないコードを書ける仕組みで、Rustが支持される理由の一つでもあります。</p>
<p>今回は所有権・ライフタイムの大まかな概念を見たあと、簡単なリスト構造を題材にこのメモリ管理機能を見ていきます。</p>
<h2 id="Rustは何を保証するか"><a href="#Rustは何を保証するか" class="headerlink" title="Rustは何を保証するか"></a>Rustは何を保証するか</h2><p>C言語などにおけるポインタをつかったメモリ管理は以下のような問題を引き起こすことが知られています。</p>
<ul>
<li>これからアクセスしようとしている領域がすでに解放済みだったり他のことに使われているなどの原因により不正なものになっている（ダングリングポインタ）</li>
<li>すでに解放されているメモリ領域を誤ってもう一度解放してしまい未定義動作を引き起こす</li>
<li>確保した領域がもう使われていないにもかかわらず解放されない（メモリリーク）</li>
</ul>
<p>Rustはガベージコレクションのような実行時でのメモリ管理ではない方法でこれらの問題を回避します。<br>Rustではポインタを使って値にアクセスすることは基本的にはありません（できないことはないのですが<code>unsafe</code>と呼ばれる特殊な操作になり、Rustが保証する安全性を損ないます）。<br>かわりに使うのが「参照」と「スマートポインタ」などの機能です。<br>これらがどのようにポインタで発生しうる問題を回避するかを見てみましょう</p>
<h2 id="参照と借用"><a href="#参照と借用" class="headerlink" title="参照と借用"></a>参照と借用</h2><p>参照の概念を説明する前にまず「所有権（ownership）」の概念について簡単に見てみます。</p>
<p>Rustのにおける値は唯一の所有者（owner）が存在します。変数に値を代入すると、その変数が値の所有者になります。<br>同じ値に対して複数の所有者が存在することはできません。<br>所有者である変数のスコープが終了すると、その値は解放されます。<br>簡単な例を挙げましょう。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ブロックの外に出たことで、aにはアクセスできなくなりaの持っていた値は解放される</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a);  <span class="comment">// この文はコンパイルエラーになる</span></span><br></pre></td></tr></table></figure>

<p>関数呼び出しや他の変数に値を渡すために所有権を渡す（ムーブ）こともできます。その場合、もともとの変数は所有権を失うので使えなくなります。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line"><span class="comment">// 下の文はもうaが使えないのでコンパイルエラーとなる</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;", a);</span></span><br></pre></td></tr></table></figure>

<p>しかし、実際には関数呼び出しや構造体のメンバーとしてポインタのようなものを持ちたい場合など、所有権がまるまる渡ってしまうのは不都合な場面があります。<br>そこでRustでは一時的に値を「借用（borrow）」する、ということができます。このときできるのが「参照（reference）」です。<br>参照のイメージとしては制限付きのポインタのようなものです。<br>関数に参照を渡す例を下に示します。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 呼び出し元から値を借用する関数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_string</span></span>(a: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    print_string(&amp;a);   <span class="comment">// aの参照を渡している</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = a;          <span class="comment">// 参照を渡すだけでは所有権は失われないので、bにムーブすることができる</span></span><br><span class="line">    </span><br><span class="line">    print_string(&amp;a);   <span class="comment">// aは所有権を失っているので参照はつくれず、コンパイルエラー</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>a</code>を借用することで所有権を失わずに関数を呼び出していますが、所有権を失っている変数への参照をつくるといったことをするとコンパイルエラーとなります。<br>このように、参照は普通のポインタとは違い、不正な値への参照がないようコンパイラが保証してます。<br>そこで登場するのが「ライフタイム（lifetime）」という概念です。<br>ライフタイムとはその参照が有効となる期間のことで、これをコンパイラがチェックすることでダングリングポインタや解放済みの領域へのアクセスというものを防いでいます。<br>他の例を見てみましょう。C言語でのダングリングポインタの例として、関数内のローカル変数へのポインタを関数の返り値にしてしまう、というものがあります。<br>以下にC言語での例を示します。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; <span class="keyword">point_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">point_t</span>* get_point(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">point_t</span> p = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">point_t</span>* p = get_point();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GCCを使いコンパイルすると、警告はでるもののコンパイルできてしまいます。<br>これを実行すると筆者の環境ではセグメンテーションフォルトになりました。ローカル変数はスタック上に確保されますが、関数が返るときに解放されてしまうので、呼び出し先（この例ではmain関数内）では使うことができません。</p>
<p>Rustで同じようなコードを参照で書こうとするとコンパイルエラーになります。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_point</span></span>&lt;<span class="symbol">'a</span>&gt;() -&gt; &amp;<span class="symbol">'a</span> Point &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;</span><br><span class="line">        x: <span class="number">0</span>,</span><br><span class="line">        y: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = get_point();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, p.x, p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>突然返り値に<code>&#39;a</code>というのが出てきましたが、これがライフタイムを表しています。今まではライフタイムを明示しなくてもコンパイラが自動的に判断できたのでつけなかったのですが、このように返り値として参照をつける場合は明示する必要があります。<br>同じライフタイムを持つ参照は同じ期間生存する必要があります。<br>コンパイラのエラーメッセージはこのようになります。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error</span>[E0515]: cannot <span class="literal">return</span> <span class="keyword">reference</span> <span class="keyword">to</span> <span class="keyword">local</span> variable `p`</span><br><span class="line">  <span class="comment">--&gt; src/main.rs:12:5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">12</span> |     &amp;p</span><br><span class="line">   |     ^^ returns <span class="keyword">a reference</span> <span class="keyword">to</span> data owned <span class="keyword">by</span> <span class="keyword">the</span> current function</span><br></pre></td></tr></table></figure>

<p><code>p</code>はローカル変数なのでそこへの参照は返すことができない、と言われています。<br>つまり<code>get_point</code>関数の返り値の参照は関数外でも生存している必要がありますが、<br>ローカル変数はライフタイムが関数内で尽きてしまうため、関数外でも生きる参照にはなれない、ということです。</p>
<h2 id="可変性"><a href="#可変性" class="headerlink" title="可変性"></a>可変性</h2><p>Rustの参照の他のおもしろい性質として、可変参照と普通の参照が区別されることでしょう。<br>実は今まで登場してきた普通の参照は参照先の値を変更することができません。<br>参照先の値を変更したい場合は<code>&amp;</code>ではなく<code>&amp;mut</code>とつけることで可変（mutable）参照を使う必要があります。<br>配列を使った例で見てみましょう。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可変参照をとることで、配列の中身を変更する</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(a: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..a.len() &#123;</span><br><span class="line">        a[i] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    add_one(&amp;<span class="keyword">mut</span> a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125; &#123;&#125;"</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vec!</code>マクロを使って<code>Vec</code>というRust標準の動的配列をつくり、その可変参照を関数に渡しています。この<code>&amp;mut</code>を<code>&amp;</code>にするとコンパイルが通りません。</p>
<p>可変参照と通常の参照を分けることによって例えば以下のようなケースでダングリングポインタを防ぐことができます。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> x = &amp;a[<span class="number">0</span>];</span><br><span class="line">    a.clear();  <span class="comment">// Vecのclear関数は可変参照をとる</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x); <span class="comment">// xの指す先はすでに解放されている</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配列<code>a</code>の先頭要素への参照を<code>x</code>として、その後<code>clear</code>を呼ぶことで配列の中身をすべて消します。<br>その後、<code>x</code>を使い解放されたはずの先頭要素を出力しようとしています。これはコンパイルされてしまえばダングリングポインタということになってしまいます。<br>実際にはこのコードは以下のようなエラーが出てコンパイルが失敗します。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `a` <span class="built_in">as</span> mutable because it is also borrowed <span class="built_in">as</span> immutable</span><br><span class="line"> --&gt; src/main.rs:<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">  |<span class="type"></span></span><br><span class="line"><span class="type">4</span> |     <span class="type">let</span> x = &amp;a[<span class="number">0</span>];</span><br><span class="line">  |              <span class="type">- immutable</span> borrow occurs here</span><br><span class="line"><span class="number">5</span> |     <span class="type">a</span>.<span class="built_in">clear</span>();  // Vecの<span class="built_in">clear</span>関数は可変参照をとる</span><br><span class="line">  |     <span class="type">^^^^^^^^^ mutable</span> borrow occurs here</span><br><span class="line"><span class="number">6</span> |     <span class="type"></span></span><br><span class="line"><span class="type">7</span> |     <span class="type">println</span>!(<span class="string">"&#123;&#125;"</span>, x); // xの指す先はすでに解放されている</span><br><span class="line">  |                    <span class="type">- immutable</span> borrow later used here</span><br></pre></td></tr></table></figure>

<p>実は可変な借用をする場合、その値に対する他の参照は存在できないというルールがあります。<br>今回の場合、<code>x</code>は<code>println!</code>で使われるあいだまでライフタイムがあるにもかかわらず、その間で可変参照をつくろとしています。<br><code>a.clear()</code>は一見するとよくわからないかもしれませんが、Rustのメソッド呼び出しをする場合、その値を借用することで呼び出されます。<br><code>clear</code>関数は以下のような定義になっています。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">clear</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>

<p><code>self</code>というのがそのメソッド呼び出しをしているインスタンスで、その可変参照をとるということです。</p>
<h2 id="リスト構造を書いてみる"><a href="#リスト構造を書いてみる" class="headerlink" title="リスト構造を書いてみる"></a>リスト構造を書いてみる</h2><p>もう少し実践的な例としてリスト構造をRustで書くことを考えます<br>今回は関数型言語でよく見かけるconsを使ったリストというのを書いていきます。consとは２つの値のペアからつくられるリストで、関数型言語だとこういうような書き方をします。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">2</span>, (<span class="name">5</span>, (<span class="name">3</span>, nil)))</span><br></pre></td></tr></table></figure>

<p>これは<code>[2, 5, 3]</code>という連結リストのようなものです。各ノードは左側を<code>car</code>、右側を<code>cdr</code>と呼びます。<br>リストは空の場合<code>nil</code>、そうでない場合先頭の値を<code>car</code>に持ち、先頭を除く残りのリストを<code>cdr</code>として持つ再帰的な構造になっています。</p>
<p>これをRust風に書いていきたいと思います。なお、このようなリストをRustで使うことはあまりなく、<code>Vec</code>のような標準で備わっている型を通常は使います。<br>リストは空の場合は<code>nil</code>でそうでない場合はペアになっているという２つのパターンがあります。このような構造をあらわすには<code>enum</code>（列挙型）を使うと便利です。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ただし、これはこのままだと定義できません。なぜなら<code>List</code>型がそのまま<code>List</code>内のメンバーに使われてしまっているからです。<br>こうしてしまうと<code>List</code>型が無限のサイズを持たなければなりません。C言語ではこういう場合はポインタを使うように、今回は参照を使って書き直してみます。<br>参照はポインタのようなもの、と先ほど説明しまいたが、コンパイルされると内部的には参照先の値へのアドレスとなります。<br>そのため、値の参照先の型によらずアドレス分のサイズしか必要ありません。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, &amp;<span class="symbol">'a</span> List&lt;<span class="symbol">'a</span>&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">2</span>, &amp;Cons(<span class="number">5</span>, &amp;Cons(<span class="number">3</span>, &amp;Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参照に明示的にライフタイムを書かなければならないことに注意してください。<br>参照はポインタと同じように内部的にはその値の先のアドレスを持つだけなので、<code>List</code>型のサイズによらずアドレスの値の分で一定なので先ほどみたいに無限のサイズにならずにすみます。<br>また今回は簡単のためリストの中身を書き換えるということは考えないことにします。</p>
<p>とりあえずリストは定義できました。次にいろいろな操作を書いてみましょう。<br>まずはリストの内容を全て出力する関数を書いてみます。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_list</span></span>(list: &amp;List) &#123;</span><br><span class="line">    <span class="keyword">match</span> list &#123;</span><br><span class="line">        Cons(val, ls) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"val: &#123;&#125;"</span>, val);</span><br><span class="line">            print_list(ls);</span><br><span class="line">        &#125;</span><br><span class="line">        Nil =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">2</span>, &amp;Cons(<span class="number">5</span>, &amp;Cons(<span class="number">3</span>, &amp;Nil)));</span><br><span class="line">    print_list(&amp;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enum</code>に対してはこのようにパターンマッチを使った操作をすることができます。<br><code>cons</code>の場合はその値を出力して、残りのリストに対して再帰的に<code>print_list</code>を呼び出し、<code>nil</code>に到達したら終了します。</p>
<p>出力結果は以下のようになります。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">val:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">val:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">val:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>さて、このリストを新たにつくる関数を考えてみましょう。<br>例えばこのリストの末尾に新たな要素を付け加えたリストを新たにつくりたいと思います。</p>
<p>関数はリスト受け取って空リストならその新たな要素１つのみを含むリストを返し、<code>cons</code>なら残りのリストに対して関数を再帰的に呼び出し、<br>その結果を<code>cdr</code>にした新しい<code>cons</code>を返すことで実現できそうです。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">append</span></span>&lt;<span class="symbol">'a</span>&gt;(list: &amp;<span class="symbol">'a</span> List, val: <span class="built_in">i32</span>) -&gt; List&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> list &#123;</span><br><span class="line">        Cons(x, ls) =&gt; &#123;</span><br><span class="line">            Cons(*x, &amp;append(ls, val))</span><br><span class="line">        &#125;,</span><br><span class="line">        Nil =&gt; &#123;</span><br><span class="line">            Cons(val, &amp;Nil)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">2</span>, &amp;Cons(<span class="number">5</span>, &amp;Cons(<span class="number">3</span>, &amp;Nil)));</span><br><span class="line">    <span class="keyword">let</span> list2 = append(&amp;list, <span class="number">7</span>);</span><br><span class="line">    print_list(&amp;list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>しかし、これは以下のようなコンパイルエラーになってしまいます。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0515]: cannot return value referencing temporary value</span><br><span class="line">  --&gt; src/main.rs:22:13</span><br><span class="line">   |</span><br><span class="line"><span class="string">22 </span>|<span class="string">             Cons(*x, &amp;append(ls, val))</span></span><br><span class="line"><span class="string">   </span>|<span class="string">             ^^^^^^^^^^---------------^</span></span><br><span class="line"><span class="string">   </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">   |<span class="string">             </span>|<span class="string">         temporary value created here</span></span><br><span class="line"><span class="string">   </span>|<span class="string">             returns a value referencing data owned by the current function</span></span><br></pre></td></tr></table></figure>

<p>再帰呼出ししてつくった値が関数内でしか生存しないので、ライフタイムが合わずエラーが出ています。<br>このように、参照のみをつかってデータ構造を定義しようとするのは非常に難しいです。どうしたらよいのでしょうか？</p>
<p>C言語の経験がある方は、このような場合メンバーはポインタで持つと思うのですが、その値をつくるときに<code>malloc</code>関数などを使いヒープ領域から値をとってくると思います。<br>Rustでもヒープ領域を扱う方法はもちろんあります。例えば、<code>String</code>型は内部的にはヒープ領域を使っています。<br>C言語の場合、<code>malloc</code>関数などでヒープ領域に確保された領域をポインタで指し示しますが、Rustでは「スマートポインタ」と呼ばれるものを使い安全にヒープ領域を扱います。</p>
<h2 id="スマートポインタを使ったヒープ領域の活用"><a href="#スマートポインタを使ったヒープ領域の活用" class="headerlink" title="スマートポインタを使ったヒープ領域の活用"></a>スマートポインタを使ったヒープ領域の活用</h2><p>スマートポインタという言葉はC++でも使われているので知っている方もいるかもしれません。<br>普通のポインタとは違い、参照のように不正な操作を防ぐための仕組みが備わっています。<br>スマートポインタといってもRustには何種類か備わっているのですが、まずは一番（？）スタンダートな<code>Box</code>というのを見てみましょう。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> boxed = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"boxed = &#123;&#125;"</span>, boxed);</span><br><span class="line">    *boxed += <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x = &#123;&#125;, boxed = &#123;&#125;"</span>, x, boxed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x</code>をつかって<code>boxed</code>という値をつくりました。この値はヒープ上に確保されて、参照のように使うことができます（<code>Deref</code>と型強制という仕組みでおこなわれているのですが詳細は割愛します）。<br><code>x</code>の値はコピーされているので、<code>boxed</code>を変更しても<code>x</code>の値は変化しません。</p>
<p>これを用いて先程の<code>List</code>の例を書き換えてみましょう。<code>Box</code>も内部的にはポインタと同じようにその先が指し示す構造によらず一定のサイズで済む型です。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_list</span></span>(list: &amp;List) &#123;</span><br><span class="line">    <span class="keyword">match</span> list &#123;</span><br><span class="line">        Cons(val, ls) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"val: &#123;&#125;"</span>, val);</span><br><span class="line">            print_list(ls);</span><br><span class="line">        &#125;</span><br><span class="line">        Nil =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line"></span><br><span class="line">    print_list(&amp;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>これは正しくコンパイルされ、先ほどと同じ出力結果を得られます。<br>先程断念した末尾に新たな要素を付け足したリストを返す、という関数も簡単に実現できるようになります。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">append</span></span>(list: &amp;List, val: <span class="built_in">i32</span>) -&gt; List &#123;</span><br><span class="line">    <span class="keyword">match</span> list &#123;</span><br><span class="line">        Cons(x, ls) =&gt; &#123;</span><br><span class="line">            Cons(*x, <span class="built_in">Box</span>::new(append(ls, val)))</span><br><span class="line">        &#125;,</span><br><span class="line">        Nil =&gt; &#123;</span><br><span class="line">            Cons(val, <span class="built_in">Box</span>::new(Nil))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">    <span class="keyword">let</span> list2 = append(&amp;list, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    print_list(&amp;list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>今度はコンパイルできて以下のような出力結果が得られます。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">val:</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">val:</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">val:</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">val:</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>なぜ今回は問題がなかったかというと、<code>Box::new</code>でつくられた値を借用するのではなく、ムーブによって所有権ごと渡されているからです。<br>内部的にも値の中身はヒープ領域にあるので関数から出てしまっても保持されているので問題ありません。</p>
<h2 id="メモリ解放について"><a href="#メモリ解放について" class="headerlink" title="メモリ解放について"></a>メモリ解放について</h2><p>関数内のローカル変数の場合、その関数が終わるときにスタックが破棄され値も解放されますが、<code>Box</code>のようにヒープを使う場合どのように解放されるのでしょうか。<br>実は<code>Box</code>には<code>Drop</code>というトレイト（C++のインターフェースのようなもの）が実装されていて、その値がスコープから出たときにメモリが解放されるような実装がされています。<br>所有権システムによりその値に紐付いている変数は複数存在することはできないので、<code>Drop</code>トレイトによって実装されたメモリ解放の動作が同じ<code>Box</code>のインスタンスに対して働くことはありません。<br>また、自分たちでわざわざどこでメモリを解放するかを明示する必要もありません。</p>
<h2 id="Rustのメモリ管理の弱点"><a href="#Rustのメモリ管理の弱点" class="headerlink" title="Rustのメモリ管理の弱点"></a>Rustのメモリ管理の弱点</h2><p>ここまでRustでのメモリの扱いについて一通り見てきました。<br>Rustがこれらの仕組みを使いメモリを安全にアクセスできるというのがわかったと思います。</p>
<p>一方で、いくつかの弱点もあります。まず、可変な参照を考慮すると問題が複雑になることです。<br>可変参照は複数つくれないことを説明しましたが、現実には複数の値に同じ値を操作するための参照を持ちたい場合というのは結構あります。<br>例えば可変な双方向連結リストがそれにあたります。リストの各ノードは前後の要素に対する参照をもつような実装になりますが、そうするとあるノードに対しての可変参照が前のノードと後ろのノードのそれぞれが持つことになってしまいます。<br>一応、そういうケースをなんとかする構造体もあるのですが、普通のポインタよりかはオーバーヘッドがつきます。</p>
<p>またRustは実はメモリリークが起きない保証はしていません。<br>確かに<code>Box</code>などは自動的にメモリを開放する仕組みが備わっていますが、意図的にそういうものを無効にする関数があります（<code>std::mem::forget</code>）。<br>普通、Rustの安全性の保証を無視する関数は<code>unsafe</code>とマークされるのですが、そのような関数は<code>unsafe</code>とされていません。</p>
<p>このように、Rustのメモリ管理も万能ではありません。しかしながら、生のポインタを使うよりかはずっと安全で、GCありの言語よりかは扱いにくいと思いますが、その分高いパフォーマンスを得ることができます。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/" target="_blank" rel="noopener">The Rustonomicon</a></li>
<li>「実践Rust入門」（技術評論社）</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-26T11:23:21.000Z"><a href="/hexo/2021/08/26/isucon11.html">2021-08-26</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2021/08/26/isucon11.html">ISUCON11予選参加記（予選敗退）</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="https://isucon.net/archives/55821036.html" target="_blank" rel="noopener">ISUCON11</a>にチーム「ビックバン・オーガニゼーション」で<a href="https://twitter.com/cympfh" target="_blank" rel="noopener">@cympfh</a>さんと<a href="https://twitter.com/dekokun" target="_blank" rel="noopener">@dekokun</a>さんと参加して、予選敗退しました。お母さんには内緒だぞ！<br><a href="/hexo/2020/09/13/isucon10-qual.html">昨年</a>は別のメンバーとですがRustを使い予選通過できましたが、今年は結果が出せませんでした。</p>
<h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>この御時世ということもあり、全員Discordでオンラインで連絡を取り合いながら去年の問題を解いていました。<br>ログ解析にはnginxのログを解析するalpを、MySQLはスロークエリをpt-query-digestで解析することにしました。<br>ウェブアプリのデプロイは手元でコンパイルしたものをrsyncでデプロイする形式をとりました。<br>サーバーの基本的な環境設定用のansibleスクリプトも用意しました。</p>
<p>また、デプロイやログ解析用のシェルスクリプトも用意しておきました。</p>
<h2 id="予選本番"><a href="#予選本番" class="headerlink" title="予選本番"></a>予選本番</h2><p>9:40からのyoutube liveには全員オンラインになってライブを視聴してました。</p>
<p>まずは、ansibleを走らせつつ、当日マニュアルを読み競技内容の確認を行いました。</p>
<p>Rustの初期実装でベンチを走らせた結果を元に、まずは適当にindexを貼りました。<br>また、nginxの設定をいじり、静的ファイルはアプリを介さずnginxで直接返すようにしました。</p>
<p>11:40頃、CPU使用率が張り付いていたのを見てDBは別サーバーで動かすことにしました。スコア7610</p>
<p>13:10頃、他のメンバーがiconのmax-ageを設定することでスコア18380</p>
<p>13:55頃、GET /api/isuの最適化のため最新のconditionをウェブアプリ内でキャッシュするようにする。スコア17992であまり変わらず</p>
<p>15:00頃、icon画像をウェブアプリ内でキャッシュするようにする。スコア18196で大きくは変わらず</p>
<p>15:50頃、POST /api/condition/{id}でリクエスト中の最新のコンディションのみをINSERTする変更を加える。スコア35050で大幅に伸びる。<br>これはGET /api/isu/{id}を叩いたときに新しいコンディションを確認したときに加点される仕組みを利用したハックでした。<br>本当は全件を一括INSERTしたかったのですが、Rust実装で使われていたsqlxはそのようなSQL文を出力するAPIを持っていなかったのでやや手間がかかるのでこういう実装にしました。<br>グラフ内のコンディション数は下がってしまうので、そこでの加点はおさえられてしまいますが、それ以上にPOSTの負荷を下げることのほうが効いたようです。</p>
<p>ここでウェブアプリのCPU負荷が高く張り付いていることに気がつき、ウェブアプリを2台立てようと試行錯誤したのですが、なぜかスコアが下がってしまう現象に見舞われ苦戦します。<br>他にもアプリケーショ内キャッシュを導入したり、DROP_PROBABILITYを変更したり、スコア計算の仕組みを利用したハックの検討などをしたのですが、全て裏目に出てしまいます。<br>そうこうしている内に競技時間が過ぎ、再起動試験をした後、ログ出力を切り最終的にはスコア39107ということで予選敗退しました。</p>
<h2 id="敗因分析"><a href="#敗因分析" class="headerlink" title="敗因分析"></a>敗因分析</h2><p>まず、ウェブアプリの分散に失敗したことですが、ウェブアプリ内でキャッシュを持っていてそれを共有していなかったのが原因のようです。<br>アクセス数のみをみてPOST /api/condition/{id}だけを別サーバーで捌く、などをしていたのですが、その場合、最新のconditionのキャッシュがPOST時に更新されないことでスコアが下がっていたようです。<br>今回、POSTの内容を全て無視しても整合性チェックで怒られることがなく、競技中は何が原因かの特定に失敗してしまいました。<br>ただし、nginxのみを分離する、ということは簡単にできたはずで、これはベンチマーク公開後に試してみたのですが、それだけでスコアが伸びそうな気配がありました（実際のスコアはベンチマーカーサーバーが非力だったためわからず）。</p>
<p>また、nginxからエラーメッセージが出ていて、リクエストがでかすぎるせいで一時ファイルが大量に生成されていることに競技中に気がつきませんでした。<br>確かにToo many open fileのエラーはアプリ側のログで確認したのですが、ulimitの変更で誤魔化していました。<br>nginxからのエラーメッセージ見逃しは去年もあったのに、同じミスを繰り返してしまいました。</p>
<p>あとは、isuテーブルからオブジェクトを引っ張るときに全てのカラムを引っ張っていたのですが、これをやめるのもかなり効果的でした。<br>これは僕は競技中に提案したのですが、そこまで優先度高くないよね、ということで先送りされていました。<br>が、実際にはicon画像が載っているカラムを引っ張ってきたりするので、かなりの負荷があったようです。<br>また、無駄なtransactionを生成している部分を消すのもかなり効いたようでした。<br>このへんはDBでの負荷が比較的少ないように見えたので、きちんとログを確認しておらず気がつきませんでした。<br>sqlxにはバグがあり、リクエストが中断したときなどにトランザクションを正常に終了できずエラーを吐くというのがあったので、<br>トランザクションを減らすことはその手のエラー処理の際のCPU負荷を軽減することにもつながっているので、Rustの場合は特に重要だったようです。<br>ただし、これらのテストはvagrant環境で同一インスタンスにベンチを含めた全てのアプリケーションを入れた場合のテスト結果なので、もしかしたら効果の大小は見誤っているかもしれません。</p>
<p>GET /api/trendはVarnishでキャッシュする戦略はかなりありだったと思います。<br>実は、事前練習でVarnishの導入は練習していたのですが、使うという発想が出てきませんでした。</p>
<p>総じて、本質的な負荷軽減があまり出来ていないにもかかわらず、チーム全体の思考がスコア計算をハックする方向に傾いてしまっていたのは痛かったと思います。<br>また、コードの変更内容をチーム全体で共有できていなくて、間違った修正が入ることも多かったので、ある程度チーム内で変更をレビューするステップを加えてもよかったと思います。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>結果こそ出せませんでしたが、今年も十分に楽しめました。運営の方々には改めて感謝です。<br>今年のルールは去年に比べると変更すべき点が多く、スコア計算の仕組みが結構複雑で戦略を問われるものになっていたと感じました。<br>個人的には、スコア計算の仕組みはシンプルに整合性を保ってリクエストを捌けた数を競うようなルールが好みなのですが、現実のアプリケーションでも厳密にすべてのリクエストを捌いて常に整合性を保つということは要求されていないことも多いと思うので、これはこれでありなのかなあとも思います。俺はどっちでもいいけど。</p>
<iframe width="312" height="176" src="https://ext.nicovideo.jp/thumb/so39063160" scrolling="no" style="border:solid 1px #ccc;" frameborder="0"><a href="https://www.nicovideo.jp/watch/so39063160" target="_blank" rel="noopener">人造昆虫カブトボーグ 第1話「親父超え！勇気のライジング・プロミネンス」</a></iframe>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-04-03T15:00:00.000Z"><a href="/hexo/2021/04/04/theseus.html">2021-04-04</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2021/04/04/theseus.html">論文紹介： Theseus: an Experiment in Operating System Structure and State Management</a></h1>
  

    </header>
    <div class="entry">
      
        <p>先日、<a href="https://connpass.com/event/201059/" target="_blank" rel="noopener">Kernel/VM探検隊 online</a>というイベントにて、RustでOSを設計するという論文をまとめて紹介するというLTを行いました。</p>
<a href="https://docs.google.com/presentation/d/1RRccgmR-EsnfanWrpyywvx4fDbohEHWuqsAoMAT6YUY/edit?usp=sharing" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://lh3.googleusercontent.com/TXzwKrUO09y9YnyCyQnJeC5gkwowPTUi7JQqiJq4XUrWyCQI87TMXf6uAXk1PTdACk5YuoeGwIOR1A=w1200-h630-p"></div><div class="descriptions"><div class="og-title">RustはOS界の銀の弾丸になりうるか</div><div class="og-description">RustはOS界の 銀の弾丸になりうるか 論文で見るRustで変わるOS設計 1</div></div></div></a>

<p>しかし、10分間のプレゼンで3本の論文を紹介するとかいう、かなり無茶苦茶な発表だったので説明している箇所もかなり限定的で、解説全体として非常に雑なものになってしまいました。<br>そこでこの記事で、このLTで触れた論文の1つであるTheseusというOSについて説明したものをもう少し詳しくみていきたいと思います。</p>
<h2 id="論文概要"><a href="#論文概要" class="headerlink" title="論文概要"></a>論文概要</h2><ul>
<li>タイトル： Theseus: an Experiment in Operating System Structure and State Management</li>
<li>著者： Kevin Boos, Namitha Liyanage, Ramla Ijaz, Lin Zhong</li>
<li>会議： 14th USENIX Symposium on Operating Systems Design and Implementation (OSDI ‘20)</li>
</ul>
<a href="https://www.usenix.org/conference/osdi20/presentation/boos" class="link-preview" target="_blank" rel="noopener"><div class="link-area"><div class="og-image"><img></div><div class="descriptions"><div class="og-title">Theseus: an Experiment in Operating System Structure and State Management | USENIX</div></div></div></a>

<p>USENIX系会議でOS関連のトップカンファレンスの一つであるOSDIの論文です。<br>先日のLTで紹介したうちのReadLeafに関する論文もこの年のこの会議で発表されたものです。</p>
<p>この論文では、OSのステートスピルというものを減らすことを目的としたOS設計を模索しています。<br>ステートスピルとは、あるコンポーネントの変更可能なステートが他のコンポーネントとのインタラクションでステートの一部が他のコンポーネント内に残ってしまい、その漏れたステートを持ったコンポーネントがクラッシュしてしまうことで、もともとのコンポーネントもその影響を受けてクラッシュするというものです。<br>このステートスピルを減らすOS設計のために、Rustのコンパイラレベルで保証される性質をOSの設計でもなるべく保つことで、ランタイムでおこなうべきことを減らせる、というのがこの論文のポイントです。</p>
<p>ちなみに「Theseus」の読み方なのですが、ギリシア神話が元ネタなのですが、日本では「テセウス」で知られていますが、著者らは英語読みで「シーシアス」、というように喋っていたので、自分もLTでは「シーシアス」と紹介しました。</p>
<h2 id="Theseusのデザインの原則"><a href="#Theseusのデザインの原則" class="headerlink" title="Theseusのデザインの原則"></a>Theseusのデザインの原則</h2><p>Theseusはcellと呼ばれるソフトウェアコンポーネントの組み合わせにより成り立ちます（Rustの<code>std::cell</code>とは関係ありません）。<br>デザインの原則として以下の3つを挙げています。</p>
<ol>
<li>すべてのcellはランタイムで永続的な（runtime-persistent）境界を持つ</li>
<li>言語とコンパイラの力を最大限活かす</li>
<li>cell間のステートスピルをなくす</li>
</ol>
<p>順にどういうことかをみていきます</p>
<p>cellはRustのクレートとして実装され、実行時にはcell間の依存関係についてのメタデータとともにロードされます。<br>ロードされたcellはCellNamespace上で管理されます。<br>各cellをクレートとして実装することで、そのクレートのオブジェクトファイルとcellが直接対応することになります。<br>cellの依存関係はクレートの依存関係と等しくなるので、循環した依存関係は発生しません。<br>このクレートして実装された境界により、後述するcellスワッピングやエラーからの復帰が簡略化されます。</p>
<p>2つ目の原則である言語とコンパイラのもたらす安全性の保証を活かすために、Theseusのランタイムモデルは言語のランタイムモデルと同じように、シングルアドレススペースで（同じメモリ領域に対して複数のアドレスをマッピングしたりしない）、単一の特権レベルで（途中で実行モードが変わったりしない）、単一のヒープ（グローバルアロケータしか使わない）で実行されるようになっています。<br>これらにより、コンパイル時に行われる型やライフタイムなどの不変条件のチェックをそのまま活用することができ、OS的に他の仕組みを導入する必要がありません。<br>Rustが保証してくれていない性質としてリソースのリーク（resource leakage）の問題があります。実はRustはメモリリークが起きないことは保証してくれません（例えば<code>std::rc::RC</code>で循環参照をつくるとメモリリークになります）。<br>ただし、ここでのリソースリークは広義のメモリリークというより、タスクがなんらかのオブジェクトを抱えたままエラーで異常終了する、といったケースを考えているようです。<br>これを防ぐために、Theseusではクリーンアップのロジックはすべて<code>Drop</code>ハンドラで実装することにし、独自のスタックアンワインディングを実装することで異常終了した場合でもリソースが解放されるようにしています。<br>このスタックアンワインディングで使う情報はすべてコンパイル時に生成されるので、実行時にコストがかかることはありません。</p>
<p>3つ目の原則であるステートスピルをなくすために、Theseusではopaque exportationという仕組みでクライアント・サーバー間で通信します。従来の場合は、サーバー側でステートを持ちその進捗とかを管理しますが、Theseusではクライアント側にそのようなステートは輸出し、所有権がクライアント側に移ります（exportation）。<br>一方でサーバー側のプライベートなステートは型安全性により守られます（opaque）。<br>こうすることで、クライアント側が所有権を持つため、クリーンアップのロジックも当然クライアント側で自動で行われるので、あえて実装する必要がなくなります。<br>複数クライアントでステートを共有する場合、<code>Arc</code>などのリファレンスカウントを持つオブジェクトを使いますが、このような場合、ステートはヒープ上におかれることになります。<br>これはヒープへのステートスピルのように見えますが、このようなヒープアロケーションそのものは<code>String</code>のようなオブジェクトをつくるときにも起こるのでそもそも避け得ないものであり、ヒープアロケーションを表す<code>Arc</code>などのオブジェクトの所有権はクライアントが持つことになり、そのオブジェクトを辿っていけばヒープにアロケートされたオブジェクトによるステートスピルも検出できるので、ヒープそのものの内部状態を考える必要はない、としています。</p>
<h2 id="具体例"><a href="#具体例" class="headerlink" title="具体例"></a>具体例</h2><p>原則２、３をLTのスライドには入れたが、発表時間の都合上吹っ飛ばしたメモリ管理の例で見てみましょう。</p>
<p>Theseusでは<code>MappedPage</code>型で仮想メモリを管理しています。シングルアドレススペースを実現するために、<code>MappedPage</code>型の所有権を保有することが対応するページとフレームの所有権を保有することを意味します。<br>よって、複数からマップされることはページとフレームの所有権を複数箇所で保有することを意味してしまうため、コンパイル時に禁止されます。<br>また、このアロケートされた領域は<code>Drop</code>ハンドラでしか解放されません。これにより、ライフタイムが尽きたときのみページとフレームが解放されるので、use-after-freeのようなバグを防ぐことができます。<br>また、writableやexecutableかも、それぞれ専用の型を用意することで、型レベルで制御しています。<br>この<code>MappedPage</code>オブジェクトをopaque exportationでは所有権ごとクライアントが受け取ることになります。サーバー側は使われている仮想メモリエリア（VMA）のリストを管理するということは必要ありません。</p>
<h2 id="CellスワッピングによるLive-Evolution"><a href="#CellスワッピングによるLive-Evolution" class="headerlink" title="CellスワッピングによるLive Evolution"></a>CellスワッピングによるLive Evolution</h2><p>Theseusは<code>nano_core</code>と呼ばれる他のcellが動的にロードされていき、cellスワッピングという仕組みで機能を拡張していきます。<br>6章で詳しく説明されているのですが、文章を書くのが疲れたので、このブログではスキップします。</p>
<h2 id="実験・評価"><a href="#実験・評価" class="headerlink" title="実験・評価"></a>実験・評価</h2><p>CellスワッピングによるLive Evolutionにより、複数のスケジューラを切り替えたり、ネットワーク越しのアップデート機能などを実際に実装しています。</p>
<p>フォルトリカバリーの仕組みがちゃんと動くかの評価のためにQEMUのエミュレーターで実行時にランダムにフォルトを挿入するという大胆な方法で実験し、MINIX3と比べクラッシュすることが少ないことを確かめています。</p>
<p>マイクロベンチマークなどを用い、オーバーヘッドが十分に少ないことを確かめていますが、Linux並みの機能を実現しているわけではないことには留意する必要があります。</p>
<h2 id="限界"><a href="#限界" class="headerlink" title="限界"></a>限界</h2><p>低レイヤーの世界ではどうしても<code>unsafe</code>を使うことが必要になります。<code>unsafe</code>コードは独立性を損ねる場合もあるので問題です。<br>また、Rustのコンパイラとcore/allocライブラリを信用しているのでそれらのsoundness holesの影響を受けてしまいます。<br>Rust言語そのものの性質に大きく依存しているので、他の言語のコンポーネントは残念ながら使えません。</p>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>いかがでしたか？ちゃんと理解できましたか？僕も正直理解できているか自信がない箇所が結構あります。<br>が、Rustを活用することでのOS設計のメリットというのが垣間見えたと思います。</p>
<p>Theseusのコードはオープンソースになっていて、実装についてのドキュメントもあるので、そちらも目を通してみるとより理解できるのではないでしょうか。自分はまだ手が回っていませんが…</p>
<p><a href="https://book.mynavi.jp/ec/products/detail/id=121220" target="_blank" rel="noopener">自作OSに関する新しい書籍</a>が発売されるなど、自作OSに対する関心が高まりつつある（？）今日この頃ですが、従来のOSとは違ったアプローチのOSを探求するというのもまたおもしろいと思います。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-01-17T07:45:56.000Z"><a href="/hexo/2021/01/17/eth-tx.html">2021-01-17</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2021/01/17/eth-tx.html">RustのSTM32向けイーサネットドライバを解説する（送信編）</a></h1>
  

    </header>
    <div class="entry">
      
        <p>STM32ボードのイーサネットドライバのRust実装である<code>stm32-eth</code>クレートの送信部分のロジックの解説をしていきます。</p>
<a href="https://github.com/stm32-rs/stm32-eth/tree/v0.1.2" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://opengraph.githubassets.com/af7ad731bc458977ea3c74e8efc77a3752aeeda23d0df5f70372c6c82f5b53d1/stm32-rs/stm32-eth"></div><div class="descriptions"><div class="og-title">GitHub - stm32-rs/stm32-eth at v0.1.2</div><div class="og-description">Embedded Ethernet driver in Rust. Contribute to stm32-rs/stm32-eth development by creating an account on GitHub.</div></div></div></a>

<p><a href="/hexo/2020/12/20/ether.html">前回の記事</a>では受信部分を解説しました。<br>そのときは、自分のOS用のドライバでの送信が成功していなかったため、受信のみの解説になってしまったのですが、<br>今回晴れて送信部分のバグがとれたので、安心して記事を書けるようになりました。</p>
<p>イーサネットモジュールの初期化部分のロジックは受信とかぶっているので省略していきます。<br>仕様書も前回記事で用いたものを使います。</p>
<h2 id="送信用ディスクリプタとバッファの用意"><a href="#送信用ディスクリプタとバッファの用意" class="headerlink" title="送信用ディスクリプタとバッファの用意"></a>送信用ディスクリプタとバッファの用意</h2><p>受信はDMAを用いてメモリにデータが書き込まれ、操作のためにはリングバッファになったディスクリプタと呼ばれる領域とそれに対応するバッファを確保する必要がありました。<br>送信もDMAを用いてメモリ上のデータを転送し、リングバッファになっているディスクリプタを用いて操作していきます。<br>リファレンスマニュアルでは33.6.7で解説されています。今回はNormal Tx DMA descriptorsを使います。</p>
<p><code>stm32-eth</code>では<code>src/tx.rs</code>の<code>TxRing</code>という構造体がこのリングバッファを抽象化したものです。<code>TxRingEntry</code>が各ディスクリプタとそれに対応するバッファを持っています。<br>この<code>TxRingEntry</code>と受信のとき使った<code>RxRingEntry</code>は共に<code>RingEntry&lt;T&gt;</code>というジェネリック型を用いて実装されていることからわかるように、共通点は多いです。ただし、フィールドの位置が微妙に違ったりするので注意しましょう。</p>
<p>この送信用ディスクリプタの初期化には以下のような処理が必要です。</p>
<ul>
<li>TDES0のOWNビットをクリアしておく。このビットがセットされているとDMA側が所持していることになるが、まだ送信するべきものがないのでCPU側で所持する</li>
<li>TDES0のTCHビットをセットすることで、セカンドアドレス連鎖を有効にする</li>
<li>リングバッファの末尾のエントリ以外の場合、TDES3に次のディスクリプタのアドレスを書き込む。最後のエントリの場合は、アドレスは設定せずにTDES0のTERビットをセットする。</li>
</ul>
<p>また、ディスクリプタは8バイトにアラインされている必要があります（ワードアライン）。</p>
<p>あと、これは前回書き忘れたのですが、DMAで書き換えられるメモリにアクセスしてポーリングなどの処理を書く場合は<code>core::ptr::read_volatile</code>を使うなどしないと最適化されてちゃんと動作しない場合があることにも注意しましょう（１敗）。</p>
<p>DMATDLARレジスタに先頭のディスクリプタのアドレスをいれ、DMAOMRのSTビットを立てれば、送信用のDMAの設定は完了です。</p>
<h2 id="DMAからデータを送信する"><a href="#DMAからデータを送信する" class="headerlink" title="DMAからデータを送信する"></a>DMAからデータを送信する</h2><p><code>Eth::send</code>から呼び出されている<code>TxRing::send</code>が送信でディスクリプタやバッファの処理をするコードです。実際に見てみましょう。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>&lt;F: <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) -&gt; R, R&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, length: <span class="built_in">usize</span>, f: F) -&gt; <span class="built_in">Result</span>&lt;R, TxError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> entries_len = <span class="keyword">self</span>.entries.len();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.entries[<span class="keyword">self</span>.next_entry].prepare_packet(length) &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">mut</span> pkt) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> r = f(pkt.deref_mut());</span><br><span class="line">            pkt.send();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">self</span>.next_entry += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.next_entry &gt;= entries_len &#123;</span><br><span class="line">                <span class="keyword">self</span>.next_entry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Ok</span>(r)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt;</span><br><span class="line">            <span class="literal">Err</span>(TxError::WouldBlock)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>関数としては送りたいデータの長さと、ドライバ内のバッファにデータを書き込むための関数を受け取り、<code>Result</code>を返すという型になっています。<br>やっていることはまず、利用可能なディスクリプタがあるか探していて、ある場合は、エントリ内のディスクリプタの下準備とバッファ領域を準備します。<br>ディスクリプタの下準備とは</p>
<ul>
<li>TDES1のTBS1にバッファサイズを書き込む</li>
<li>TDES2にバッファのアドレスを書き込む</li>
</ul>
<p>の２つです。バッファは<code>TxEntry</code>内のバッファのうち、必要な長さのみのスライスへのミュータブルな参照として渡されます。<br>引数として渡される関数はこのスライスにデータを書き込むこととなります。</p>
<p>その後、準備したバッファ領域に対して受け取った関数<code>f</code>を実行します。<br><code>pkt.send()</code>はTDES0のOWNビットを立てる処理でこれでこのエントリがDMA側で処理される準備ができたことになります。<br>リングバッファのカウンターを更新したら、<code>Ok</code>を返しておしまいです。</p>
<p>最後に呼び出し元の<code>Eth::send</code>が<code>TxRing::demand_poll</code>を呼び出していますが、これはDMATPDRレジスタに1を書き込むことによってDMAが送信ディスクリプタをポーリングするように要求するものです。</p>
<p>受信とは違い、最後に<code>Drop</code>等は特に実装する必要はないです。</p>
<h2 id="送信用バッファについて"><a href="#送信用バッファについて" class="headerlink" title="送信用バッファについて"></a>送信用バッファについて</h2><p>この<code>stm32-eth</code>では送信用バッファとディスクリプタを１つの構造体にまとめ上げていますが、実はこうする必要はあんまりなかったりします。<br>そもそもディスクリプタできちんと指定してあげれば、バッファのアドレスに特に縛りはありません。</p>
<p>この実装だと非行率的な例をいくつかあげます。<br>まず、送信用バッファとは別のメモリ上にすでに出来上がったパケットが存在している場合（例えば定数になっている場合）、引数として与えられる関数<code>f</code>はメモリ間のデータコピーをするだけとなってしまいます。<br>また、現状の実装では<code>TxEntry</code>を確保した後、送信用バッファにデータを用意するという流れになっていますが、実際は送信用のデータの用意はTxEntryの確保前でもよいはずです。<br>このデータの用意がそこそこ時間のかかるものであれば、無駄にTxEntryを確保する時間が長くなってしまいます。</p>
<p><code>send</code>関数を任意のアドレスとその長さを渡すような関数にしてしまう、という実装にすればこのような問題は解決されそうです。<br>が、ひとつ注意しなければならないのはライフタイムの問題です。<br>DMAでアクセスされるバッファ領域が送信中に解放されてしまい別のデータが入るなどとなれば送信が失敗してしまいます。<br>なので、バッファ領域はライフタイム制約を入れた参照として受け取るとよいでしょう。この場合の制約はドライバと同じ区間生存する、というものならば大丈夫でしょう。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>最後のバグの原因はGPIOの設定がひとつだけ間違っていた、というものだったのですが、気がつくまで相当しんどかったです。<br>とりあえずちゃんと実装できて一安心です。<br>送信は受信とは違った実装ポイントがあるので、もっと作り込めばおもしろそうだなと思いました。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-12-27T15:00:00.000Z"><a href="/hexo/2020/12/28/poem.html">2020-12-28</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2020/12/28/poem.html">2020年の振り返り</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="今年の成果"><a href="#今年の成果" class="headerlink" title="今年の成果"></a>今年の成果</h2><p>まずはブログ記事だが、今年はこの記事を含めずに9本で去年より少なくなっている。<br>一応、<a href="https://zenn.dev/garasubo/articles/64118a8cf240b24c40fc" target="_blank" rel="noopener">zenn.dev</a>にも記事を書いたが、それを含めても少ない。<br>また、自作OSプロジェクトだが、今年は新しいモジュールは<a href="/hexo/2020/12/20/ether.html">イーサネットドライバの受信部分のみ</a>であまり進捗は出ていない。</p>
<p>と去年やっていた分野では停滞気味になってしまったが、他の形での成果はいくつか上がった。<br>1つは<a href="https://garasubo.github.io/embedded-book/index.html">Rustでの自作OS入門のドキュメント</a>で、これは予想以上に反響をもらった。<br>こういうまとまったドキュメントを書くのはあまり経験がなかったのだが、はてなブックマークでのトレンド入りするなどしていたらしい（普段そういうサービスを使っていないので気がつかなかった）。</p>
<p>各種プログラミングコンテストにもぼちぼち参加した。AtCoderではABCに何回か出るほか、AtCoder Problmesを利用して毎月一程度の問題数をこなすようにした。<br>短時間で集中してコーディングするという能力がまだまだだと感じているので、ABCにちゃんとオンタイムで参加して緊張感のある状態で問題を解くという回数は増やした（時間帯が変わってくれるともうちょっと楽なのだが）。<br>ISUCONでは初めて予選通過できた。が、本選では散々な結果だったしまだまだ知識量も足りていないという部分も感じられた。<br>予選はトラブルも多く実力を発揮しきれなかったチームも一定数あることを考えると、運に助けられた部分もあったと思う。<br>しかしながら、ノウハウは自分の中で蓄積できつつあるのは感じているし、予選通過自体は素直に前進であったとポジティブに捉えてはいる。<br>ICFPCにも出ていた。チームはベストメンバーがそろっていたが、14位で去年と同じくらい。チームの中ではGalaxy Padの仕様をエスパーするのが一番得意という何とも言えない強味でサポートできた。できればもうちょっと他の面でもサポートできれば良かったのだが、なかなか難しい。</p>
<p>オープンソースへのコントリビューションはいくつかのプロジェクトに小さな貢献が何件かあったが、あまり大きな貢献はできなかった。<br>一応、winitというRust製のウィンドウシステムのライブラリに<a href="https://github.com/rust-windowing/winit/issues/1497" target="_blank" rel="noopener">IME関連のイベントをサポートする</a>というのに貢献を続けている。<br>が、MacとWindowsの環境への実装ができてないためまだマージはされていない。<br>これがマージされると他のデスクトップアプリケーションでIMEイベントに対応した機能がいろいろ実装できるのでぜひマージされてほしいが、手持ちにまともなMacとWindowsの開発環境がないので難しい。</p>
<p>他には<a href="https://connpass.com/event/180812/" target="_blank" rel="noopener">Arm入門勉強会</a>というイベントで<a href="/hexo/2016/05/23/t-visor.html">過去に作った自作ハイパーバイザ</a>の話をするとかした。<br>オンラインのこういう勉強会にはちょくちょく今後も顔を出していきたい。</p>
<p>トータルで見れば去年の成果からは思ったよりは伸びなかったが、決して進歩がないわけでもないといったところか。<br>今年は新型コロナの影響やらなんやらでモチベーションを保つのが難しかったり、生活スタイルを変えなければならなかったりといろいろ厳しいなか、それなりにうまくやれた気もする。</p>
<h2 id="政治のこととか"><a href="#政治のこととか" class="headerlink" title="政治のこととか"></a>政治のこととか</h2><p>普段、Twitterとかで政治とか社会問題に関する言及はあんまりしないようにしている。<br>それらに関する専門知識をさほど持ち合わせているわけでもなく、この手の議論をSNS上で繰り広げてもろくなことにならないケースが多すぎるからである。<br>とはいえ、自分に直接関係するようなことに対して全くもって言及しない、というのはそれはそれで違うだろうとも思うので、いくつかの問題については言及をあえてした。<br>年末なので、自分の考えを整理する目的でここに書くが、別にこれに関して反論とかをぶつけてきても必ずしも反応するわけではない、ということは予め断っておく。<br>またお約束ではあるが、あくまで個人の見解であり、所属する団体を代表するものでもない。</p>
<h3 id="COVID-19"><a href="#COVID-19" class="headerlink" title="COVID-19"></a>COVID-19</h3><p>新型コロナウイルスの流行は、無関係な人間は全くいないといっても過言ではないくらい社会にインパクトを与えてしまった。<br>3月の頭あたりから会社でも全員原則在宅勤務となり、正直その当時はオーバーリアクションなのでは、とも感じていたのだが、全くもって甘い考えであったことはその後の状況を見てのとおり。</p>
<p>一部では流行は自然収束するとか、日本人は免疫を持っているとか楽観説を唱える言論も少なからずあったわけだけど、現状の国内外のデータと照らし合わせれば説得力はほぼ皆無になりつつあると思う。<br>自分には医学的な知識はほとんどないので、論文を読んで本当に正しそうみたいな議論は残念ながらできないが、日本の分科会に属する医学の専門家たちの知見はおおむね信頼していいのだろうと思っている。<br>もっとも、その知見に基づいてきちんとしたアクションがとられているかどうか、メッセージの発信の仕方などには議論はあるとは思うけど。</p>
<p>大手メディアの報道もかなりいい加減で、かなり信憑性が低い言説であったり、専門家のメッセージもかなり歪に切り取られることも少なくなかった。<br>このあたりはそこまで驚きではなかったが、 自分の観測範囲のそこそこ知識もきちんとあると思っている人たちですら、怪しい言説をシェアしたり、流行初期にあった日本は意図的に感染者数を隠しているのような陰謀説に加担するひとすらいたのは正直驚いた。<br>なので、自分は分科会が上げる資料を時々目を通したり、感染者数の動向の生データをみたり、こういう専門家と矛盾していない解説をしてくれるTwitterアカウントを非公開リストにいれて（信憑性はだいぶ落ちるであろうことに留意しつつ）ウォッチしている。</p>
<p>自分は幸いにも大きく収入が落ち込むということはなかったが、人との接触が歓迎されないという状況が長く続くというのは気分がよくない。在宅勤務も正直そこまで好きじゃない。<br>おそらく来年中にコロナ問題が完全解決とはならず、一定の制限が続くのではないかなと理解しているが、一日も早く事態が好転するのを願わずにはいられない。</p>
<h3 id="Coinhive裁判"><a href="#Coinhive裁判" class="headerlink" title="Coinhive裁判"></a>Coinhive裁判</h3><p>Coinhiveを設置したウェブアプリケーション製作者が逮捕され裁判になるという事件があり、地裁では無罪になったが今年2月の高裁判決では逆転有罪となってしまった。<br>自分はこのケースを無罪になるべきだと思っている。<br>詳しい説明は日本ハッカー協会の寄稿などがわかりやすいと思うので、ここでは詳しく解説しない。</p>
<a href="https://www.hacker.or.jp/coinhiveopinion/" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img></div><div class="descriptions"><div class="og-title">【寄稿】コインハイブ事件　意見書ご協力のお願い - 一般社団法人日本ハッカー協会</div></div></div></a>

<p>Coinhiveに関しては知り合いでも有罪になるべきではないか、という意見の人が少なからずいたりする。<br>そういう主張の背景にはCoinhiveを設置するのは金儲けのためで悪意に満ちたものという思い込みであったり、あるいは倫理観にかけた行為であるという点でそういう意見になっていると思っている。<br>しかしながら、ウェブアプリケーションを運営するにあたってなんらかの収益化は必要不可欠だし、倫理観にかける＝違法であるわけではないしそこは議論をきちんと分けるべきと思う。<br>もうちょっと踏み込むと、そもそも倫理観にかけた行為であったのか、という点も議論の残る点ではある。<br>例えば有名なセキュリティソフトの開発元のNortonは、自社製品でこのようなマイニングスクリプトをブロックするようにしてはいるものの、100％悪として断罪はできないだろうとしている。</p>
<a href="https://japan.norton.com/coinhive-9678" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://now.symassets.com/content/dam/norton/ja/images/blog/malware/coinhive-00-730x382.jpg"></div><div class="descriptions"><div class="og-title">自分のPCやスマホが使われるCoinhiveとは？その特徴と防衛策</div><div class="og-description">そもそもcoinhiveとは何かという基本の解説から、coinhiveがなぜ問題視されているのか、そしてcoinhiveに勝手なことをされたくないという方のための対処法などをまとめました。</div></div></div></a>

<p>そもそもウェブ関連の倫理観というのはまだまだ成熟が甘く、どこからがアウトでどこまでがセーフかという線引きが難しい事案は多くあると思う。<br>他の産業の倫理観を引き合いに非難するというのも、ブラウザというサンドボックス内で実行されるアプリケーションという性質を考えると適当ではないだろう。<br>もっとも今ではブラウザ標準でこのようなスクリプトは弾かれるようになっているし、こういう手法は今なら倫理的ではないと言えるかもしれない。</p>
<p>たしかに、ウェブ関連のアプリケーションはかなりの大手ですら倫理的にどうなの、と思うようなことを平気でやっていたりするので、健全な状態とは言い難いとは思う。<br>しかしながら、このようにぽっと出の技術を使った個人開発者を叩いても、このような現状が好転するようなながれにはならないとは思う。</p>
<h2 id="来年について"><a href="#来年について" class="headerlink" title="来年について"></a>来年について</h2><p>もうそろそろ若手とは言い難い年齢になってきたので、できるだけ多くのことに今のうちに学んでいけたらと思っている。<br>具体的には</p>
<ul>
<li>実際に広く使われている組込みRTOSの仕様や実装を学ぶ（Rustに限らない）</li>
<li>ARMv8-Aでのベアメタルプログラミング</li>
<li>ネットワークスタックについての理解</li>
<li>ウェブアプリケーションのセキュリティ施策</li>
<li>OSSに関するより粒度の大きい貢献</li>
</ul>
<p>あたりが面白いテーマかなと思っている。おそらく全部をカバーするのは難しいと思うけど。</p>
<p>あとはコロナの影響で難しくなってきてはいるが、人との交流は増やしたいとぼんやり思っている。<br>もともと、人と積極的に親しくするというのは苦手で、所属しているグループで孤立するということはないのだが、例えばプライベートで会って遊ぶみたいな機会はほとんどなかったりする。<br>人との距離を見誤り怒られたり、立ち入ってはいけない領域に踏み入れてしまうということも、ちょっと前だと少なくなかったように思う。<br>最近だとないがそれは単に人との距離を詰めるのをさぼっているだけ、という気もする。<br>人との交流が少なくなると自分の精神的にもよくないというのは感じているので、なんらかの方法で増やせないかなあと思うのだが、はてさてどうすればいいのやら。</p>
<p>今年もあと数日残っているし、この年末に大きなニュースが入ってくるというのも珍しくないのだが、暇なので振り返ってみた。<br>来年も引き続き技術的なことを発信できていけたらなあと思う。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-12-19T15:00:00.000Z"><a href="/hexo/2020/12/20/ether.html">2020-12-20</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2020/12/20/ether.html">RustのSTM32向けイーサネットドライバを解説する（受信編）</a></h1>
  

    </header>
    <div class="entry">
      
        <p>この記事は<a href="https://adventar.org/calendars/4954" target="_blank" rel="noopener">自作OS Advent Calendar 2020</a>の20日目の記事です。</p>
<p><a href="/hexo/2019/05/15/erkos.html">RustでSTM32ボード用の自作OS</a>をしていて、アプリケーションの幅を増やしたくて、イーサネットドライバを組むことにしました。<br>使用しているのはNucleo-429ZIボードで、イーサネットモジュールが付属しています。<br>去年から取り組みはじめてはいたものの、今までのペリフェラルとは違い仕様が複雑で何度も挫折して中断しまくったのですが、ようやく受信部分だけ完成したので解説していきたいと思います。</p>
<p>参照するコードは自分が組んだコードでもよかったのですが、送信部分がバグっているのと、参考にしてきた<code>stm32-eth</code>クレートのほうがずっと出来が良いのでそちらを使います。<br>なお、バージョンはv0.1.2とちょっと古いバージョンです。なお、<code>stm32-eth</code>のこのバージョンではいくつか立てる必要のないと思われるビットを立てていたりするので、実際に参考にする場合はちゃんと仕様書で確認しながら見ることをおすすめします。</p>
<a href="https://github.com/stm32-rs/stm32-eth/tree/v0.1.2" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://opengraph.githubassets.com/af7ad731bc458977ea3c74e8efc77a3752aeeda23d0df5f70372c6c82f5b53d1/stm32-rs/stm32-eth"></div><div class="descriptions"><div class="og-title">GitHub - stm32-rs/stm32-eth at v0.1.2</div><div class="og-description">Embedded Ethernet driver in Rust. Contribute to stm32-rs/stm32-eth development by creating an account on GitHub.</div></div></div></a>

<h2 id="仕様書を入手する"><a href="#仕様書を入手する" class="headerlink" title="仕様書を入手する"></a>仕様書を入手する</h2><p>仕様書なくしてドライバはつくれません。今回はCPUのリファレンスマニュアルとデータシート、ボードのユーザーマニュアルがまず必要です。<br>更に、イーサネット通信は外部物理層(PHY)に対してIEEE 802.3で定義されているインターフェスを介してCPUのイーサーネットモジュールと通信することで実現されています。<br>このPHYに関するマニュアルも必要です。ユーザーマニュアルによるとこのボードではLAN8742A-CZ-TRを使っているとのことなので、これの仕様書も入手しましょう。</p>
<ul>
<li><p><a href="https://www.stmcu.jp/design/document/reference_manual/51544/" target="_blank" rel="noopener">STM32F42xxxのリファレンスマニュアル</a></p>
</li>
<li><p><a href="https://www.st.com/resource/en/datasheet/stm32f429zi.pdf" target="_blank" rel="noopener">STM32F429xxのデータシート</a></p>
</li>
<li><p><a href="https://www.st.com/content/st_com/ja/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-nucleo-boards/nucleo-f429zi.html" target="_blank" rel="noopener">Nucleo-144ボードのユーザーマニュアル</a></p>
</li>
<li><p><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/DS_LAN8742_00001989A.pdf" target="_blank" rel="noopener">LAN8742A/LAN8742Aiの仕様書</a></p>
</li>
</ul>
<h2 id="セットアップ"><a href="#セットアップ" class="headerlink" title="セットアップ"></a>セットアップ</h2><p>イーサネットモジュールを使うにはまずGPIOやクロックの供給などの初期設定をする必要があります。<br>GPIOのピンのうちいくつかを適切なAlternateモード設定するのですが、リファレンスマニュアルの方の33.3章のTable 185にピンの対応関係が書いてあります。<br>しかし、これをよく見ると複数のピンに同じ機能が割り当てられているのがわかると思います。実はボードのユーザマニュアル6.11章にこのボードで利用可能なマッピングがちゃんと書かれています。<br>なので、ピンの設定はボードのマニュアルを参照しましょう。<br>Alternateモードの11がイーサネット用のモードです。設定方法は8章のGPIOの章を参照しましょう。</p>
<p>PHYとの通信方法はReduced Media-independent Interface(RMII)と呼ばれる方法を使います。これはMIIより少ないピン数で通信できる方法です。<br>リファレンスマニュアル33.4.4で書かれているように、RMIIを使うにはSYSCFG_PMCレジスタで23ビット目を立てる必要があります。</p>
<p>クロックの供給はSYSCFGとイーサネットモジュール、使うGPIOに対して行う必要があります。GPIOはA,B,C,Gを使います。</p>
<p><code>stm32-eth</code>でこれらのことをやっているのが、<code>src/setup.rs</code>の<code>setup</code>関数と<code>setup_pins</code>関数となっています。</p>
<h2 id="イーサネットモジュールの初期化"><a href="#イーサネットモジュールの初期化" class="headerlink" title="イーサネットモジュールの初期化"></a>イーサネットモジュールの初期化</h2><p>続いてイーサネットモジュールの初期化を行います。<code>stm32-eth</code>では<code>src/lib.rs</code>の<code>Eth::init</code>に相当する部分です。<br>この初期化には送信に関係する設定もおこなっている場合があります。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">fn init<span class="params">(&amp;mut self)</span> -&gt; &amp;Self &#123;</span><br><span class="line">    self.reset_dma_and_wait<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="string">//</span> <span class="keyword">set</span> clock range in MAC MII address register</span><br><span class="line">    let clock_range = ETH_MACMIIAR_CR_HCLK_DIV_16;</span><br><span class="line">    self.eth_mac.macmiiar.modify<span class="params">(|_, w| unsafe &#123; w.cr()</span><span class="string">.bits</span><span class="params">(clock_range)</span> &#125;);</span><br><span class="line"></span><br><span class="line">    self.get_phy<span class="params">()</span></span><br><span class="line">        <span class="string">.reset</span><span class="params">()</span></span><br><span class="line">        <span class="string">.set_autoneg</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="string">//</span> Configuration Register</span><br><span class="line">    self.eth_mac.maccr.modify<span class="params">(|_, w| &#123;</span></span><br><span class="line"><span class="params">        // CRC stripping for Type frames</span></span><br><span class="line"><span class="params">        w.cstf()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Fast Ethernet speed</span><br><span class="line">            <span class="string">.fes</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Duplex mode</span><br><span class="line">            <span class="string">.dm</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Automatic pad/CRC stripping</span><br><span class="line">            <span class="string">.apcs</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Retry disable in half-duplex mode</span><br><span class="line">            <span class="string">.rd</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Receiver enable</span><br><span class="line">            <span class="string">.re</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Transmitter enable</span><br><span class="line">            <span class="string">.te</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="string">//</span> frame filter register</span><br><span class="line">    self.eth_mac.macffr.modify<span class="params">(|_, w| &#123;</span></span><br><span class="line"><span class="params">        // Receive All</span></span><br><span class="line"><span class="params">        w.ra()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Promiscuous mode</span><br><span class="line">            <span class="string">.pm</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="string">//</span> Flow Control Register</span><br><span class="line">    self.eth_mac.macfcr.modify<span class="params">(|_, w| &#123;</span></span><br><span class="line"><span class="params">        // Pause time</span></span><br><span class="line"><span class="params">        w.pt()</span><span class="string">.bits</span><span class="params">(0x100)</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="string">//</span> operation mode register</span><br><span class="line">    self.eth_dma.dmaomr.modify<span class="params">(|_, w| &#123;</span></span><br><span class="line"><span class="params">        // Dropping of TCP/IP checksum error frames disable</span></span><br><span class="line"><span class="params">        w.dtcefd()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Receive store and forward</span><br><span class="line">            <span class="string">.rsf</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Disable flushing of received frames</span><br><span class="line">            <span class="string">.dfrf</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Transmit store and forward</span><br><span class="line">            <span class="string">.tsf</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Forward error frames</span><br><span class="line">            <span class="string">.fef</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Operate on second frame</span><br><span class="line">            <span class="string">.osf</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="string">//</span> bus mode register</span><br><span class="line">    self.eth_dma.dmabmr.modify<span class="params">(|_, w| unsafe &#123;</span></span><br><span class="line"><span class="params">        // Address-aligned beats</span></span><br><span class="line"><span class="params">        w.aab()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Fixed burst</span><br><span class="line">            <span class="string">.fb</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">            <span class="string">//</span> Rx DMA PBL</span><br><span class="line">            <span class="string">.rdp</span><span class="params">()</span><span class="string">.bits</span><span class="params">(32)</span></span><br><span class="line">            <span class="string">//</span> Programmable burst length</span><br><span class="line">            <span class="string">.pbl</span><span class="params">()</span><span class="string">.bits</span><span class="params">(32)</span></span><br><span class="line">            <span class="string">//</span> Rx Tx priority ratio 2<span class="function">:1</span></span><br><span class="line">            <span class="string">.pm</span><span class="params">()</span><span class="string">.bits</span><span class="params">(0b01)</span></span><br><span class="line">            <span class="string">//</span> Use separate PBL</span><br><span class="line">            <span class="string">.usp</span><span class="params">()</span><span class="string">.set_bit</span><span class="params">()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>まずは、DMAのソフトウェアリセットをかけています。DMABMRレジスタのSRビット（ビット0）をセットするとDMAコントローラのソフトウェアリセットになり、<br>リセットが終了すると自動的にクリアされるのでそれを待ちます。</p>
<p>次にPHYモジュールとアクセスするための設定をしていきます。まずは、MIIでPHYのレジスタにアクセスするための下準備として、MACMIIARレジスタのビット4:2でクロックの範囲を指定します。<br>データシートの3.31章によると、25MHzで動作するようなので、<code>0b010</code>にセットすればよさそうです。<br>PHYモジュールのレジスタアクセスは、MACMIIARに読み書きしたいレジスタ番号と読み書きのモードを指定してMACMIIDRに書き込みなら自分でデータを書き込み、読み込みならばこのレジスタに値がPHYから書き込まれます。<br>動作の完了はMACMIIARのMBビットがクリアされることによりわかります。</p>
<p>具体的なPHYモジュールのレジスタの説明はLANの仕様書の4.2章からたどることができます。<br>Basic Control Registerの15ビットをセットすることでソフトリセットをしたのち、12ビットと9ビットを立てることでAuto-Negotiationを有効にすることで、<br>ハードウェア側で勝手にパラメータ調整を任せることができます。<br>そのあと、PHY special control/status register(31)の12ビットが立っていれば、auto-negotiationが完了したことがわかります（が、stm32-ethでは確認していないようです。いいのかな？）。</p>
<p>あとは、ペリフェラルのMAC側とDMA側の設定をおこなっていくことになります。<br>MACCRのCSTF・FES・DM・APCS・RD・RE・TEビットを立て（RDビットはDMビットを立てて全二重モードにしているのでおそらく無視されている）、MACFFRのRA・PMビットを立て、MACFCRのPTフィールドでポーズ時間を設定し、DMAOMRでDTCEFD・RSF・DFRF・TSF・FEF・OSFを立て、DMABMRのAAB・FB・RDP・PBL・PM・USPフィールドの値を設定しています。<br>これらのフィールドすべてを解説するのはしんどいので、マニュアルを参照してください。</p>
<h2 id="受信用ディスクリプタとバッファの用意"><a href="#受信用ディスクリプタとバッファの用意" class="headerlink" title="受信用ディスクリプタとバッファの用意"></a>受信用ディスクリプタとバッファの用意</h2><p>イーサネットのデータはDMAを介してメモリに読み書きされます。そのためのディスクリプタと呼ばれるメモリ領域を確保しないといけません。また、送信されてきたデータが書き込まれるバッファも必要です。これらをリングバッファとしてDMAは利用します。<br>リファレンスマニュアルでは33.6.8で解説されています。今回はNormal Rx DMA descriptorsを使います。</p>
<p><code>stm32-eth</code>では<code>src/rx.rs</code>の<code>RxRing</code>という構造体がこのリングバッファを抽象化したものです。<code>RxRingEntry</code>が各ディスクリプタとそれに対応するバッファを持っています。<br><code>src/lib.rs</code>の<code>Eth::new</code>でこれらの初期化をしたのち、DMAレジスタに値を書き込んでこのリングバッファを使うようにしています。</p>
<p>初期化処理で必要なのは</p>
<ul>
<li>RDES0のOWNビットを立てることで、DMA側にディスクリプタの所有権を譲る</li>
<li>RDES1のRBS1でバッファのサイズを指定し、RCHビットを立ててセカンドアドレス連鎖を有効化しておく</li>
<li>RDES2にバッファのアドレスを登録</li>
<li>RDES3に次のディスクリプタのアドレスを登録する。リングバッファの最後のエントリの場合、RDES3は設定せず、RDES1のRERビットを立てる</li>
</ul>
<p>です。またディスクリプタは8バイトにアラインされている必要があります（ワードアライン）。</p>
<p>アラインメントを実現するために、stm32-ethでは<code>aligned</code>というクレートを使ってアラインメントを保証しています。<br>また、<code>RxRingEntry</code>にはバッファとディスクリプタが対となって格納されていますが、必ずしも対になっている必要はなく、RDES2にきちんとアドレスを格納しておけば基本的にRAMのどこでも構いません。</p>
<p>DMARDLARレジスタに先頭のディスクリプタのアドレスをいれ、DMAOMRのSRビットを立てれば、受信用のDMAの設定は完了です。</p>
<h2 id="DMAからデータを受信する"><a href="#DMAからデータを受信する" class="headerlink" title="DMAからデータを受信する"></a>DMAからデータを受信する</h2><p>DMAからデータを受信してみましょう。本来は正しく設定して、データが来る毎に割り込みを発生させて処理させるのがいいのでしょうが、今回はポーリングで行きます。<br><code>RxRing::recv_next</code>を見てみましょう。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">recv_next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, eth_dma: &amp;ETHERNET_DMA) -&gt; <span class="built_in">Result</span>&lt;RxPacket, RxError&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ! <span class="keyword">self</span>.running_state(eth_dma).is_running() &#123;</span><br><span class="line">        <span class="keyword">self</span>.demand_poll(eth_dma);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> entries_len = <span class="keyword">self</span>.entries.len();</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">self</span>.entries[<span class="keyword">self</span>.next_entry].take_received();</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="literal">Err</span>(RxError::WouldBlock) =&gt; &#123;&#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.next_entry += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.next_entry &gt;= entries_len &#123;</span><br><span class="line">                <span class="keyword">self</span>.next_entry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>まずはDMASRのRPSフィールドをみて受信処理状態を見ています。<br>もし、実行中になっていない場合は、DMARPDRに1をセットして受信ポールを要求します。</p>
<p><code>take_received</code>は受信が完了しているエントリを取り出すメソッドになっています。<br>受信完了すると、RDES0のOWNビットがクリアされCPU側に渡されたことが示されています。<br>また、FSビットとLSビットをみてこのディスクリプタに対応するバッファにすべてデータが入っているかを確認しています。<br>バッファの長さより長いデータが来た場合は通常は次のエントリに続きのデータが格納されています。<br>しかし今回、バッファのサイズはデータシートにかかれているVLANフレームの最大長の1522バイトなので、2つのディスクリプタにデータがまたがることを想定しないつくりになっているようです。</p>
<p><code>take_received</code>は<code>RxPacket</code>という構造体が返されていて、<code>Deref</code>によって、データが格納されたバッファへのスライスへの参照に型強制させることにより、読み込みが可能になります。<br><code>RxPacket</code>からはディスクリプタやデータが格納されていないバッファへの操作はライブラリ外からはできないようになっている、というわけです。</p>
<p>エントリを使い終わったら本来であればOWNビットを立て直すことでリングバッファに復帰させる必要がありますが、<code>recv_next</code>内ではこれからバッファのデータを読み込むわけなのでそれができていません。<br>ではどうするかというと、<code>Drop</code>として<code>RxPacket</code>がライフタイムを終えるとOWNビットが立てられるようになっています。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> RxPacket&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.entry.desc_mut().set_owned();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>これぞRustの力、という感じでこのあたりの設計は非常に参考になりました。</p>
<h2 id="テスト"><a href="#テスト" class="headerlink" title="テスト"></a>テスト</h2><p>受け取ったパケットをシリアルで垂れ流す、という方法でテストしました。<br>適当にLANにつなげば何かしらのパケットは流れてくるし、そうでない場合は、<a href="http://kozos.jp/software/pkttools.html" target="_blank" rel="noopener">pkttools</a>などを使いわかりやすいパケットを流せばいいと思います。</p>
<p>以下はstm32-ethを使ったサンプルコードです。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> stm32f4xx_hal::&#123;</span><br><span class="line">    gpio::GpioExt,</span><br><span class="line">    stm32::Peripherals,</span><br><span class="line">    serial::config::Config,</span><br><span class="line">    serial::Serial,</span><br><span class="line">    stm32::RCC,</span><br><span class="line">    rcc::RccExt,</span><br><span class="line">    time::&#123;Bps, U32Ext&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> stm32_eth::&#123;Eth, RingEntry&#125;;</span><br><span class="line"><span class="keyword">use</span> cortex_m_rt::entry;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write <span class="keyword">as</span> FmtWrite&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> panic_halt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[entry]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Peripherals::take().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup pins and initialize clocks.</span></span><br><span class="line">    <span class="keyword">let</span> gpiod = p.GPIOD.split();</span><br><span class="line"></span><br><span class="line">    stm32_eth::setup(&amp;p.RCC, &amp;p.SYSCFG);</span><br><span class="line">    <span class="keyword">let</span> gpioa = p.GPIOA.split();</span><br><span class="line">    <span class="keyword">let</span> gpiob = p.GPIOB.split();</span><br><span class="line">    <span class="keyword">let</span> gpioc = p.GPIOC.split();</span><br><span class="line">    <span class="keyword">let</span> gpiog = p.GPIOG.split();</span><br><span class="line">    stm32_eth::setup_pins(</span><br><span class="line">        gpioa.pa1, gpioa.pa2, gpioa.pa7, gpiob.pb13, gpioc.pc1,</span><br><span class="line">        gpioc.pc4, gpioc.pc5, gpiog.pg11, gpiog.pg13</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Allocate the ring buffers</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> rx_ring: [RingEntry&lt;_&gt;; <span class="number">8</span>] = <span class="built_in">Default</span>::<span class="keyword">default</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tx_ring: [RingEntry&lt;_&gt;; <span class="number">2</span>] = <span class="built_in">Default</span>::<span class="keyword">default</span>();</span><br><span class="line">    <span class="comment">// Instantiate driver</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> eth = Eth::new(</span><br><span class="line">        p.ETHERNET_MAC, p.ETHERNET_DMA,</span><br><span class="line">        &amp;<span class="keyword">mut</span> rx_ring[..], &amp;<span class="keyword">mut</span> tx_ring[..]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> rcc = p.RCC.constrain();</span><br><span class="line">    <span class="keyword">let</span> clocks = rcc.cfgr.freeze();</span><br><span class="line">    <span class="keyword">let</span> pd8 = gpiod.pd8.into_alternate_af7();</span><br><span class="line">    <span class="keyword">let</span> pd9 = gpiod.pd9.into_alternate_af7();</span><br><span class="line">    <span class="keyword">let</span> config = Config::<span class="keyword">default</span>().baudrate(<span class="number">115_200u32</span>.bps());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> serial = Serial::usart3(p.USART3, (pd8, pd9), config, clocks).unwrap();</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tx, _) = serial.split();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(pkt) = eth.recv_next() &#123;</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> pkt.iter() &#123;</span><br><span class="line">                tx.write_char(*p <span class="keyword">as</span> <span class="built_in">char</span>).unwrap();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>仕様書だけでは何をすればいいのかを読み解くのが大変で、他の実装を参考にしながら手探りで実装していったのでそれなりに大変だった。<br>送信部分もこみで解説するつもりだったが、受信部分だけでもそれなりのボリュームになったので、まあ、これはこれでいいかな、と思っている。<br>近日中に送信部分も解説記事を書きたい。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-10-03T15:00:00.000Z"><a href="/hexo/2020/10/04/isucon10-final.html">2020-10-04</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2020/10/04/isucon10-final.html">ISUCON10決勝に参加しました</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="/hexo/2020/09/13/isucon10-qual.html">ISUCON10予選でなんと勝ち抜くことができた</a>ので、決勝に参加しました。<br>チーム名は「勉強不足の分は有り余る才能でカバーしようかなと思っております」で、チームメイトは<a href="https://twitter.com/kenkoooo" target="_blank" rel="noopener">@kenkoooo</a>さんと<a href="https://twitter.com/GolDDranks" target="_blank" rel="noopener">@GolDDranks</a>さんでした。<br>今回もフルリモートでの参加になりました。<br>決勝に残ったチームとしては唯一のRustを使うチームになりました。</p>
<p>まだ、公式には点数が公表されていませんが、おそらく再起動試験で落ちて失格扱いだと思います。<br>再起動試験に通っていても競技中の最高スコアは11411点程度だったので入賞には程遠かったと思います。</p>
<p>今回は学生の一人チームが優勝したということでかなり驚いています。去年の予選は一人で参加して本当に何もできなく、<br>今回の決勝も対処すべき問題がいろいろと散りばめられているので、一人で全部なんとかしてしまうのは本当にすごいと思います。</p>
<h2 id="当日やったこと"><a href="#当日やったこと" class="headerlink" title="当日やったこと"></a>当日やったこと</h2><p>自分の視点からやったことを振り返ります。</p>
<p>8時半頃：起床。今回は前日にちゃんと睡眠がとれてコンディションはよいように感じた。</p>
<p>10時の競技開始前まで：朝食、朝のリングフィット、出前や飲み物などの準備</p>
<p>10時：今回は予定通りに競技がスタート。運営の皆様、お疲れ様です。</p>
<p>いつもどおりansibleスクリプトを走らせたり、マニュアルをチェックしたり、サーバーの構成を確認したり。<br>Ubuntu20.04になっていたことでうまく動かないところもあったが、なんとか修正してセットアップ。</p>
<p>今回はMySQLのバージョンも8にデフォルトでなっている他、サーバーはいつものnginxではなくenvoyになっているのでアクセスログのセットアップにかなり手間取ってしまった。<br>また、サーバーは3台与えられたが、スペックがそれぞれ異なり1台目は1GBのメモリに2コアのCPUだったが、2台目は2GBのメモリが、3台目は4コアにと増強されていた。<br>メモリが少なくてansibleスクリプトを走らせながらだとベンチマークが通らなかったりした。<br>とりあえず、メモリが多い2台目をメインのサーバーとして使うことにした。<br>Rust実装に切り替えてスコアは7000点程度という感じだった。</p>
<p>12時頃：アクセスログが取れるようになり、ボトルネック分析ができるようになる。<br>その間、@GolDDranksさんがダッシュボードAPIのキャッシュを導入したり、@kenkooooさんがチーム上限をいじったりしていた。<br>チーム上限をいじって異常に負荷をかけるとenvoyが途中で落ちてしまい、ベンチマークが動かないことがわかったので、下手にいじらないことにした。</p>
<p>12時半頃：SQLのログを見て適当にindexを張ってみる。今回は予選での反省を活かし、<code>pt-query-digest</code>を活用して改善が見込まれそうなクエリを探していった</p>
<p>13時15分頃：サーバー複数台の準備。コア数の多い3台目をアプリケーションに、2台目をSQLサーバーにという構成にしてみる。</p>
<p>実は初期実装に微妙なバグがあって、SQLサーバーのホスト名の参照すべき環境変数が間違っておりちょっと手間取る。<br>ベンチを回してみたところ、2台目をアプリケーションに、3台目をSQLサーバーにしたほうがよさそうだったので、とりあえずそういう構成に。<br>最終的にスコアが9928まで上がる。</p>
<p>14時50分頃：ダッシュボードAPIのキャッシュが導入されるもベンチは通らず。キャッシュの生存判定が緩すぎたっぽい</p>
<p>15時10分頃：Rust側でgzipを有効化。スレッド数の変更も試したが、かえってスコアが落ちるのでやめておく。<br>SQLのログを見ていると、コンテスト情報をとってくるためのSQLが頻繁に呼ばれているので、それをアプリケーション側でなんとかすることを思いついたので実装開始。</p>
<p>16時半頃：ダッシュボードAPIのキャッシュの生存判定をいじって1万を突破</p>
<p>16時50分頃：自分のコンテスト情報をアプリケーション側でキャッシュする実装が導入される、が、あんまりスコアが伸びない。<br>ダッシュボードAPIのキャッシュが効いて、そもそもこのSQLがそんなに呼ばれなくなったことが原因か</p>
<p>17時頃：3台目が余裕がありそうなのに対し、2台目がキツキツだったので、構成を再度逆にしようとする。<br>が、ベンチを回してみたところ、サーバーがフリーズ。メモリが枯渇したらしい。運営にサーバーを強制的に再起動してもらって、その後スワップメモリを導入しておく。</p>
<p>17時20分頃：＠GolDDranksさんが一部のSQLのロックの除去を試みるも、ベンチ通らず。<br>サーバー構成変更も原因不明のエラーが出てしまってうまくいかなかったので、諦めて再起動試験やログを切るなどの最終調整に移行する。</p>
<p>17時50分頃：ベンチマークガチャを、と思い何回か回すが、直後に今回は追試でのスコアが最終スコアということを思い出し、無意味ということに気がつく。<br>とはいうものの、もうやれることもないので、撤退。最高スコアは11411点でした。</p>
<p>20時頃：結果発表。特に賞はもらえず。</p>
<p>後にコンテストサーバーに再度ログイン可能ということで調べたのだったが、なぜかブラウザからの動作確認ができないことに気がつく。<br>原因を追跡すると、自分の導入したコンテスト情報のキャッシュロジックが間違っていることに気がつく。<br>このキャッシュロジックは<code>/initialize</code>をするときにキャッシュに値を挿入するのだが、アプリケーションを再起動するとこのキャッシュの値は当然消える。<br>ベンチマークを実行している間はアプリケーションは再起動しないし、絶対<code>/initialize</code>が最初に呼ばれるのでエラーは起きないのだが、<br>今回の再起動試験は、サーバーを再起動させた直後ブラウザからの動作を確認する、というものが含まれていて、ブラウザから動作確認する場合は<code>/initialize</code>は当然呼ばれない。<br>そのため、サーバーがコンテスト情報をDBから取得できずにエラーを返してしまうため、おそらく失格になったと思われる。</p>
<h2 id="感想・反省"><a href="#感想・反省" class="headerlink" title="感想・反省"></a>感想・反省</h2><p>再起動試験に落ちなかったとしても、1位が4万点台のスコアを叩き出していることを考えると、優勝までは程遠かった、ということがわかる。<br>サーバーは2台しか活用できなかったし、それもスペックをフルに活かせていない構成だったので、このへんの構成を変えただけでももっとスコアは伸びたと思う。<br>DBの詳細なチューニングも十分にする時間はなく、かなりやることが多いな、という印象でした。</p>
<p>envoyに振り回されたところもあるので、nginxなどある程度経験のあるものへの切り替えも視野に入れるべきだったかもしれません。が、切り替えられるほど習熟しているかどうかも怪しく、踏み切れませんでした。</p>
<p>戦略もあんまり正しくなかったかもしれません。もうちょっと俯瞰的にどこがボトルネックになっているかを手を動かす前に詳細に分析してあげることも必要だったと思います。<br>例えば、今回のアプリはAPIアプリとベンチマーカーの2つの構成となっていたのですが、このうち片方を別サーバーにしてあげるとかでも負荷分散ができたはずです。<br>どうやったらサーバー3台を活かすことができたのかがおそらく勝負の鍵だったと思うので、DBを分ける、程度しかできなかったのは敗因として大きかったと思います。</p>
<p>あとは、マニュアルをもっと読み込んで、再起動試験を真面目にやるべきでした。再起動後のベンチマーク試験のパスは確認していたのですが、ブラウザからの追試は完全に抜けていました。</p>
<p>優勝したチームは一人で全部やったらしいですが、そういう超人でない以上、チーム内での役割分担とかはもうちょっとなんとかできたかもしれません。<br>ただ、即席チームで決勝までこれたのはかなりよかったのかなあと思います。<br>来年も機会があれば、なんらかの形で参加したいです。</p>
<p>最後に、毎年このコンテストを開催してくれる運営の皆様、ありがとうございました。今回はRustという自分が好きな言語での実装が提供されてとても楽しかったです。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-09-12T15:00:00.000Z"><a href="/hexo/2020/09/13/isucon10-qual.html">2020-09-13</a></time>
      
      
  
    <h1 class="title"><a href="/hexo/2020/09/13/isucon10-qual.html">ISUCON10 予選参加記（予選通過しました）</a></h1>
  

    </header>
    <div class="entry">
      
        <p><a href="http://isucon.net/archives/54704557.html" target="_blank" rel="noopener">ISUCON10</a>にチーム「勉強不足の分は有り余る才能でカバーでカバーしようかなと思っております」で<a href="https://twitter.com/kenkoooo" target="_blank" rel="noopener">@kenkoooo</a>さんと<a href="https://twitter.com/GolDDranks" target="_blank" rel="noopener">@GolDDranks</a>さんと参加して、予選通過しました。<br><a href="/hexo/2018/09/17/isucon.html">一昨年</a>は、違うメンバーとですが出場したものの予選敗退、<a href="/hexo/2019/09/26/isucon9.html">昨年</a>は一人でNode.jsで参加するもののGoの参考実装のスコアすら超えられない悲惨な結果でした。<br>今回はRustでの参考実装が提供されそうだったというのと、Go言語を今更勉強するのもなあという気持ちもあったところに、<br>@kenkooooさんがRustを使うチームメイトを募集していたので誘いにのり、Rustにしました。</p>
<h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>事前練習としてISUCON9の予選問題をGoからRustに切り替えつつ最適化する、という練習をしていました。<br>ここでactixやsqlxの使い方を勉強しつつ、ISUCONで必要になる計測やチューニング方法の確認をしました</p>
<p>計測ツールとしてはnginxのログを<a href="https://github.com/tkuchiki/alp" target="_blank" rel="noopener">alp</a>で解析する方法と、<a href="https://blog.newrelic.co.jp/developers/how-to-utilize-isucon-special-license/" target="_blank" rel="noopener">NewRelic</a>の使い方を確認しました。<br>また、CPU使用率やメモリ使用率などをリアルタイムで監視できる<a href="https://github.com/netdata/netdata" target="_blank" rel="noopener">netdata</a>も用意しておきました。</p>
<p>デプロイの手順も確認しておいて、チームメンバー間でのコードを共有はgithubのレポジトリを介してやりましたが、サーバーへのデプロイは手元のビルド生成物をrsyncでデプロイする形式をとりました。<br>理由としてはコンパイルがそれなりにサーバーに負荷をかけること、サーバーに入ってgit pullしたりするのはいろいろと面倒な場面があることが上げられます。</p>
<p><code>/etc</code>以下のファイルは<a href="https://wiki.archlinux.jp/index.php/Etckeeper" target="_blank" rel="noopener">etckeeper</a>で管理しておきます。サーバーごとに変えたいとか権限の問題もあるので、特にリモートレポジトリでの管理はせず、ダイレクトに編集します。</p>
<p>事前にサーバーの環境はUbuntuであるとわかっていたので、例年通り自前の<a href="https://docs.ansible.com/" target="_blank" rel="noopener">ansible</a>スクリプトで各種ツールの導入や基本的なbashrcやvimrcの導入もできるようにしておきました。</p>
<h2 id="当日の流れ"><a href="#当日の流れ" class="headerlink" title="当日の流れ"></a>当日の流れ</h2><p>自分の視点から、当日の流れはこんな感じになった。</p>
<p>8時位：起床。入眠失敗してかなりつらい</p>
<p>9時位：PCを起動して支度をしていると、開始が2時間延期になったことを知る</p>
<p>12時位まで：リングフィットしたり、AtCoderの問題といたり、トイレの便座カバーを洗濯したり、お昼の出前をとったり</p>
<p>12時20分：競技開始。しかし、ポータルの不具合によりすぐにはベンチマーカーは走らせられない状態とのこと。</p>
<p>事前に用意しておいたansibleスクリプトを走らせて基本的な設定は済ませつつ、ゆっくりとコードを読んだりマニュアル読んだり、開発環境を整えたり。<br>各サーバーにsshできること、データベースにも接続できることなどを確認。<br>@kenkooooさんがgithubにウェブアプリのコードを共有し、各エンドポイント用の関数を別ファイルに切り出すことで編集がしやすいように手配</p>
<p>13時15分頃：ベンチマークが走らせられるようになる。</p>
<p>初回実行時のスコアは537<br>ベンチマークを走らせた結果をnginxのログからalpでどのエンドポイントがボトルネックになるかを観察。<br><code>/api/estate/search</code>などは回数が多いが、一回の実行あたりの時間が長そうなのは<code>/api/estate/nazotte</code>だな、などとあたりをつける。</p>
<p>自分は<code>/api/estate/search</code>のコードを見るものの、例年みたいにN+1問題のような感じでもなく、純粋にSQLクエリが重いだけっぽい。<br>ということで、インデックスを適当に張ってみたり、MySQLの設定を見直すということに注目する。</p>
<p>14時35分頃：@kenkooooさんの手によって、server2をMySQL専用にして、server1をウェブアプリ専用にする設定が導入される。server3はこの段階では使ってない。</p>
<p>ポータルが不安定だったり、nginxのログ設定がうまくいってなかったり、アプリケーションの挙動の確認などで、ここらへんはわりとあたふたしている。<br>@GolDDranksさんがボットフィルター入れたりなどの変更はあるものの、大きなスコアの変化はなし。</p>
<p>15時45分頃：nginxの設定を見直してみる。</p>
<p>静的ファイル配信周りに最適化の余地がありそうだったが、よくよくレギュレーションを見ると、<code>/api</code>以下のパフォーマンスしか見られないらしいのでスルーする。<br>gzipとかが有効になってなさそうなので、Rustアプリ側で圧縮を有効化してみたり、ワーカーの数を4にしてみたり。<br>ワーカー数はデフォルトだとCPUの数に等しくなり、今回は1コアだったのでワーカーが1つのみになるので、これだとIO待ちとかが有効活用されないのでは、と思って4にしてみた。<br>が、この辺の変更でもスコアは大きくは変わらず。500点台が続く</p>
<p>16時10分頃：@kenkooooさんのnazotteの変更が入る。</p>
<p>この辺からスコアが伸び始める。インデックスを張ったりすることで700点台に入る。<br>この段階でベンチマークを回すときにnetdataのダッシュボードを見るとMySQLサーバーのCPU使用率が非常に高いことに気がつく。一方でアプリ側は余裕がある。<br>メモリの使用率も全体としてはまだ余裕がある。この辺に注目すればスコアが伸びるのでは、と予想をつける。</p>
<p>16時50分頃：DB2台体制の準備に取り掛かる</p>
<p>MySQLサーバーのCPU使用率がボトルネックになってそう、ということは、サーバー数を増やせばスコアが伸びるのでは、と考えた。<br>今回のクエリはテーブル間でJOINすることでスコアが伸びることはなさそうだったのと、テーブル数はたったの２つのみ。<br>ということは、各テーブルごとに専用のサーバーを立てれば、比較的容易に負荷分散ができそうだ、ということに気がついて実装に取り掛かる。</p>
<p>その間に他のチームメイトはアプリケーション側でデータをキャッシュすることなどで高速化を測り、スコアが1000点台に乗り始める。</p>
<p>18時半頃：使ってなかったserver3を追加してDB2台体制が整う。</p>
<p>この時点でのスコアは1775。一気に伸び始める。</p>
<p>18時50分頃：MySQLの設定を見直していたら、実はクエリキャッシュがきいていないことに気がつく</p>
<p><code>query_cache_size</code>がデフォルトで正の値が設定されていたので、てっきり有効になっていると思ってましたが、<br><code>query_cache_type</code>がデフォルトだと0に設定されて無効になっていました。1に変えて有効化すると、なんとスコアが2465に一気に伸びる！<br>キャッシュサイズが大きすぎるとCPUの負荷も上がるかもなあと思って、大きくは変更しませんでした。</p>
<p>19時頃：時々、ベンチマークが落ちるようになる</p>
<p>アプリケーション側のキャッシュロジックがかなり怪しかったので、ここを他のメンバーが見直しつつ、自分はSQLの設定をいじったり、インデックスの貼り方を見直したり。<br><a href="https://github.com/major/MySQLTuner-perl" target="_blank" rel="noopener">MySQLTuner</a>というのを使ったんですが、どうもサーバーが貧弱すぎるせいか、まずRAMを増設せよ、みたいなアドバイスが出てきたりして、あまり活用できませんでした。<br>インデックスの仕組みも自分があまり勉強したことがなかったため、適当な複合インデックスを貼ったりはしていたのですが、果たして効果があったかはよく検証できませんでした。</p>
<p>20時頃：@kenkooooさんが離脱</p>
<p>まだ、アプリが不安定な状態が続いていたので、アプリケーション側のキャッシュロジックを全部取り外すことに。<br>一時的に3000点台も記録しましたが、キャッシュロジックを取り除くと2500点付近まで落ちてしまうことに…<br>とはいうものの、残り時間もわずかで、凍結前のスコアボードを見るに、この点数でも十分に決勝に残れそうだったのでこのままいくことに。<br>本当は再起動試験を真面目にやりたかったのですが、再起動の手順を確認しておらず、万が一再起不能になると運営からの救済も厳しい時間帯だと思ったので、行わないことに。<br>ただ、設定はすべてファイル経由でおこなっていたし、systemdのRust側のサービスのみが有効になっていることだけを確認はしておいたので、まあ大丈夫だろうと。</p>
<p>netdataなどを落としたり、ログのレベルを落としたりして、スコアガチャの時間に。2684点が終了10分前あたりに出て、ここで作業ストップ。<br>不必要なsshコネクションを落としたりして、天命を待つことに。</p>
<p>24時頃：結果発表。予選通過！</p>
<p>正直、今までの結果もそこまで良くなかったので、まさか通過できるとは思ってませんでした。<br>チームも即席で、チーム内のコミュニケーションもすべてテキストチャットで不安な面もありましたが、意外となんとかなりました。<br>この手のプログラミングコンテストでここまでいい成績を残せたのははじめてな気がします。<br>本戦も引き続きがんばっていきたいです。</p>
<h2 id="反省"><a href="#反省" class="headerlink" title="反省"></a>反省</h2><p>良かった点</p>
<ul>
<li>テキストチャットのみでも比較的コミュニケーションはとれる<ul>
<li>ボイスチャットだと不必要なインターセプトも入る可能性があるので、テキストのみというのは意外と悪くないかも</li>
<li>個人の好みや場面に依存はすると思う</li>
</ul>
</li>
<li>エンドポイント毎にファイルを切り出すのはよかった。見通しがよくなる</li>
<li>netdata等の監視ツールは大事。ansibleなどで自動で入れられるとすごく楽<ul>
<li>NewRelicも用意はしていたが、今回は活用できませんでした</li>
</ul>
</li>
<li>お昼ご飯はとても大事。今回はスポンサーである出前館を利用として、<a href="https://twitter.com/garasubo/status/1304619515750150145" target="_blank" rel="noopener">出前を注文しておきました</a><ul>
<li>参加費と思って、ちゃんといいものを食べましょう</li>
</ul>
</li>
</ul>
<p>悪かった点</p>
<ul>
<li>再起動試験の手順はもっと早くに確認しよう</li>
<li>MySQLのインデックスについてなど、ちゃんと勉強しよう<ul>
<li>5.7では降順インデックスは存在しないらしい。8では存在する</li>
<li>Generated Columnをソート用に使うというテクニックもあるらしい<br>− 他にも不要なSELECT FOR UPDATEを取り除ける、というのも見逃していた<br>− 前日の睡眠はきちんととりましょう…</li>
</ul>
</li>
</ul>
<h2 id="9-14-追記"><a href="#9-14-追記" class="headerlink" title="9/14 追記"></a>9/14 追記</h2><p>チームメイトの@kenkooooさん視点の参加記です。</p>
<a href="https://kenkoooo.hatenablog.com/entry/2020/09/13/090517" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://ogimage.blog.st-hatena.com/8454420450081554074/26006613627179021/1599962419"></div><div class="descriptions"><div class="og-title">ISUCON10参加記 - 宇宙ツイッタラーXの憂鬱</div><div class="og-description">ISUCON10に garasubo さんと GolDDranks さんとチーム「勉強不足の分は有り余る才能でカバーでカバーしようかなと思っております」で参加して予選通過しました。チーム名がtypoしているのですが、一度登録すると修正できない仕様なので、カバーでカバーするしかない…</div></div></div></a>

<p>他のチームの参戦記もいろいろ読ませてもらって、自分たちのできてなかった改善点はだいたいこんなところだと思います</p>
<ul>
<li>実行結果をアプリ側でキャッシュする<ul>
<li><code>low_priced</code>が主か。自分たちもやろうとしたが、バグらせてしまい断念</li>
</ul>
</li>
<li>MySQL 8.xの使用</li>
<li>nginxの<code>client_body_buffer_size</code>の調整<br>  − nginxのログをちゃんと見ると警告が出ていたらしい</li>
<li>MySQLの真面目な解析<br>  − <code>long_query_time=0</code>として全部スロークエリとしてログに吐かせたあと<code>pt-query-digest</code>で解析するといいっぽい<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.6/ja/explain-output.html" target="_blank" rel="noopener"><code>EXPLAIN</code>句</a>を使うとインデックスがちゃんと効いているか確認できる</li>
</ul>
</li>
<li><code>recommended_estate</code>の<code>WHERE</code>句の最適化<ul>
<li>椅子の高さ・幅・奥行きのうち下位2つのみを取り出せば、ORによる連結が減らせる。GENERATED COLUMNを活用すれば、さらに減らせる</li>
</ul>
</li>
</ul>
<p>その他、他のチームの参戦記は以下の公式のブログにまとめられるそうです。</p>
<a href="http://isucon.net/archives/55007694.html" class="link-preview" target="_blank"><div class="link-area"><div class="og-image"><img src="https://livedoor.blogimg.jp/isucon/imgs/8/3/83930b51-s.png"></div><div class="descriptions"><div class="og-title">ISUCON10 関連エントリまとめ : ISUCON公式Blog</div><div class="og-description">2020.10.16 11:09 最新更新 2020.10.5 本選も含むよう変更 2020.9.14 11:55 初版公開 --- ISUCON10にご参加いただいた皆さん、ありがとうございました！ こちらでは感想エントリや何をしたかに言及されたエントリをまとめていきます。見つ…</div></div></div></a>

<p>今回、はじめて初期実装としてRust言語が追加されたことに関しては運営の皆様とそれに協力してくださったボランティアの方に深く感謝します。<br>初期実装がない状態だと敗戦濃厚でした。また、実装自体もちゃんとしていて不利になることがありませんでした。</p>
<p>一方で、今回の大会ではポータルの不調が例年に比べると目立ち、多くのチームが混乱しているように見えました。<br>自分たちもキャッシュロジックの追加時、ポータルの不調に出会い、アプリが悪いかベンチマークが悪いかでかなり混乱してしまいました。<br>アクセスができない時間帯もありましたが、僕個人としては、そういう時間は冷静に次に何ができるかを見直せる時間になったりしたので、大きくは影響しなかったのかなと思ってます。<br>特に今年は予選が一日に集中している関係でかかる負荷が想定よりも重かったなどの事情もあったのでしょうか。<br>この点は少々、残念ではありましたが、毎年多大な労力をかけて開催していただけることは非常にありがたいと思っています。<br>運営の皆様には改めて感謝の気持ちを伝えたいと思います。ほんとうにありがとうございます。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/hexo/page/2/" class="alignright next">次の投稿</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="検索">
    <input type="hidden" name="q" value="site:garasubo.github.io/hexo">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最近の投稿</h3>
  <ul class="entry">
    
      <li>
        <a href="/hexo/2022/09/16/isucon12.html">ISUCON12予選敗戦記</a>
      </li>
    
      <li>
        <a href="/hexo/2021/12/31/nenmatsu-poem.html">2021年の振り返り</a>
      </li>
    
      <li>
        <a href="/hexo/2021/11/07/rust-memory.html">Rustのメモリ管理機能とその特徴</a>
      </li>
    
      <li>
        <a href="/hexo/2021/08/26/isucon11.html">ISUCON11予選参加記（予選敗退）</a>
      </li>
    
      <li>
        <a href="/hexo/2021/04/04/theseus.html">論文紹介： Theseus: an Experiment in Operating System Structure and State Management</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
<a class="twitter-timeline" data-height="600" href="https://twitter.com/garasubo">Tweets by garasubo</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>



  

  
<div class="widget tag">
  <h3 class="title">タグ</h3>
  <ul class="entry">
  
    <li><a href="/hexo/tags/Arm/">Arm</a><small>2</small></li>
  
    <li><a href="/hexo/tags/CLI/">CLI</a><small>1</small></li>
  
    <li><a href="/hexo/tags/Cortex-M/">Cortex-M</a><small>2</small></li>
  
    <li><a href="/hexo/tags/Kernel-VM/">Kernel/VM</a><small>2</small></li>
  
    <li><a href="/hexo/tags/Rust/">Rust</a><small>16</small></li>
  
    <li><a href="/hexo/tags/embedded/">embedded</a><small>1</small></li>
  
    <li><a href="/hexo/tags/isucon/">isucon</a><small>6</small></li>
  
    <li><a href="/hexo/tags/osdev/">osdev</a><small>6</small></li>
  
    <li><a href="/hexo/tags/paper/">paper</a><small>10</small></li>
  
    <li><a href="/hexo/tags/procon/">procon</a><small>2</small></li>
  
    <li><a href="/hexo/tags/rust/">rust</a><small>1</small></li>
  
    <li><a href="/hexo/tags/unikernel/">unikernel</a><small>3</small></li>
  
    <li><a href="/hexo/tags/x11/">x11</a><small>1</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2022 garasubo
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/hexo/js/jquery.imagesloaded.min.js"></script>
<script src="/hexo/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'garasubo';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/hexo/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/hexo/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
